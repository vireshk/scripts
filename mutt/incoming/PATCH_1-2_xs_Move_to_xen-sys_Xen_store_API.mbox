From vireshk  Mon Oct 10 08:57:57 2022
Delivered-To: viresh.kumar@linaro.org
Received: from pop.gmail.com [74.125.24.109] 	by vireshk-i7 with POP3 (fetchmail-6.4.2) 	for <vireshk@localhost> (single-drop); Mon, 10 Oct 2022 08:57:57 +0530 (IST)
Received: by 2002:a05:600c:378b:0:0:0:0 with SMTP id o11csp1487548wmr;         Thu, 29 Sep 2022 14:24:20 -0700 (PDT)
X-Received: by 2002:a17:90a:1c02:b0:1e0:df7:31f2 with SMTP id s2-20020a17090a1c0200b001e00df731f2mr17814939pjs.222.1664486659800;         Thu, 29 Sep 2022 14:24:19 -0700 (PDT)
ARC-Seal: i=1; a=rsa-sha256; t=1664486659; cv=none;         d=google.com; s=arc-20160816;         b=NTnyvKiOa/9oPuY75kHvgRzgjORHDOKUdjQb0lI4ijclooWu1YXwB9zFFrLz2HiM1F          fP9wzUMDUiiPRKMyqpxT8w6MU4LC9/FNMl8l0JUhixizyc+/UL5lNs9NIXdFFc26dWYT          ssBiCQu9NiNVuUVQGB9FifyGWczvbl25p+GM+NU5LO9HWoouJFAG7hce4Xr+wpxhXtR6          0WiBjwL21hz4Prk4COHF9ZSOIwGE7+YmG58sBgJMdjGlUonvZFRnlIuLcQOIGlmawGb4          JpXhKeY8tNWOjbNoy4oPoXkNjmNnKEjM5BSyH9wLcRzTNpTrtJP4watLn2xwa1rptVH6          A6VQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=arc-20160816;         h=content-transfer-encoding:mime-version:references:in-reply-to          :message-id:date:subject:cc:to:from:dkim-signature;         bh=mWZIXczl6jTprMPcgQSxGweb+4BNnLzJ3OSiywO7O9U=;         b=bvB8f725fZQFOtWym3FpcbDLrGiUB3AodUSVZ7nclHFxf/rgQufwjc6EbDxmZKkekc          XHTQYrZdYdCac9FwJc5CkSNL/QlrdZWLquvzKcucxpIiD1BJOvRJPm0T4SlIhJfQkYVm          E6P8C98g9HlfiL7tIH/wbO3CfwTPCRcy/YMN7ohswwv6Tro3b1yDi/A26dWINft8c/Ht          QhXujiFwrcIHS5WBmnecCRRXZy8Fr3vs/ihkc0eVhE58JNvx95VqPMcGj/N9OnjkQMse          wlfmwI+s0I1xePvvCRtUYdrPJqUyC3K96THM6D5uYOwZSVOBqayWkjbeiJwyEaL04oW0          tQnw==
ARC-Authentication-Results: i=1; mx.google.com;        dkim=pass header.i=@linaro.org header.s=google header.b=hQrhJoKU;        spf=pass (google.com: domain of mathieu.poirier@linaro.org designates 209.85.220.41 as permitted sender) smtp.mailfrom=mathieu.poirier@linaro.org;        dmarc=pass (p=NONE sp=NONE dis=NONE) header.from=linaro.org
Return-Path: <mathieu.poirier@linaro.org>
Received: from mail-sor-f41.google.com (mail-sor-f41.google.com. [209.85.220.41])         by mx.google.com with SMTPS id l10-20020a170903244a00b0016f1eb130desor352205pls.97.2022.09.29.14.24.19         for <viresh.kumar@linaro.org>         (Google Transport Security);         Thu, 29 Sep 2022 14:24:19 -0700 (PDT)
Received-SPF: pass (google.com: domain of mathieu.poirier@linaro.org designates 209.85.220.41 as permitted sender) client-ip=209.85.220.41;
Authentication-Results: mx.google.com;        dkim=pass header.i=@linaro.org header.s=google header.b=hQrhJoKU;        spf=pass (google.com: domain of mathieu.poirier@linaro.org designates 209.85.220.41 as permitted sender) smtp.mailfrom=mathieu.poirier@linaro.org;        dmarc=pass (p=NONE sp=NONE dis=NONE) header.from=linaro.org
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;         d=linaro.org; s=google;         h=content-transfer-encoding:mime-version:references:in-reply-to          :message-id:date:subject:cc:to:from:from:to:cc:subject:date;         bh=mWZIXczl6jTprMPcgQSxGweb+4BNnLzJ3OSiywO7O9U=;         b=hQrhJoKUK9z07qTfu1OHBlg96nk1JGQ3nvHC4gcnH9F/JDd2Ce8kMdQjQ9x+PFHTOh          a217wrdFdZh1YJZzX6h0vrIa7uKfpMlSSe4QJF6D9eXQbkQvJMdiWwbSehzM2tCeTlgk          YVg2VEDLdHD/FFC1RbLNk/0hbhsHQgmQvCUMQxJYH/3dMudfF8vSB+kzAmQBNkV8X5cb          i4uEwKUBKteKe6WZl6sItYOEkUaCU3ndZVXjXXa+SZr1HS0Z28uAza8GPZ97RBofnYD5          siMWb/M2LhdU7glnBRet3zHJjltu2MBOyRlvtHuoMAvF3f+m21AGygN/SBpbm2Vd/R4I          s3Wg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;         d=1e100.net; s=20210112;         h=content-transfer-encoding:mime-version:references:in-reply-to          :message-id:date:subject:cc:to:from:x-gm-message-state:from:to:cc          :subject:date;         bh=mWZIXczl6jTprMPcgQSxGweb+4BNnLzJ3OSiywO7O9U=;         b=7q8we2X8e0Uojg2jR4e9coptIZzVMZCpLRdQ4rLKzmS+qc/BquweDushNlSn2w/hIl          182vfp2hm+KaZtAPXVF+iF1ZB6iRqFgYJsBEdekrt4we04teV1C+KjnQqV3+P7Ae6RZo          VzpSPIydwy1DMvWFWP/pycqmA8YC1eDeOhuKdhLS0ikmoshnyrfWluepF3uQAhmUnz8f          OFjeUyHDtRmSTxqOvD8amk9LPKuMbQ5eC3mjx5R6o9emfZnORT/8zxNkrWqfp8Gvsygf          f3Sc+bLzLDUbWfhfGPBQDKrLZp9XRrazHM0KPuLw1Ndh/BwP1tXemQ8B2uy/sX4NZr67          2GXg==
X-Gm-Message-State: ACrzQf0exuio0CuBAMucrl3HPFqTpbYPp8p4D1D5MboVg4DL0vCbxngo 	RyELBLmUYi95hxk5dZiFMkBv2ixsgD0TZENE
X-Google-Smtp-Source: AMsMyM6kI0ViGigG4feYXgvVdQ2o3rldo5WdXxtIukI5ywNqC6QfkAlr0IRCNd4IcI5Eg5b5pc852A==
X-Received: by 2002:a17:902:9881:b0:178:6506:bbf9 with SMTP id s1-20020a170902988100b001786506bbf9mr5413004plp.80.1664486658700;         Thu, 29 Sep 2022 14:24:18 -0700 (PDT)
Return-Path: <mathieu.poirier@linaro.org>
Received: from p14s.cg.shawcable.net (S0106889e681aac74.cg.shawcable.net. [68.147.0.187])         by smtp.gmail.com with ESMTPSA id n6-20020a170903110600b0016ee3d7220esm372611plh.24.2022.09.29.14.24.16         (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);         Thu, 29 Sep 2022 14:24:17 -0700 (PDT)
From: Mathieu Poirier <mathieu.poirier@linaro.org>
To: viresh.kumar@linaro.org
Cc: alex.bennee@linaro.org
Subject: [PATCH 1/2] xs: Move to xen-sys Xen store API
Date: Thu, 29 Sep 2022 15:24:11 -0600
Message-Id: <20220929212412.3125480-2-mathieu.poirier@linaro.org>
X-Mailer: git-send-email 2.25.1
In-Reply-To: <20220929212412.3125480-1-mathieu.poirier@linaro.org>
References: <20220929212412.3125480-1-mathieu.poirier@linaro.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Length: 16528
Lines: 570

Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
---
 Cargo.lock  |  25 +++-
 Cargo.toml  |   1 +
 src/main.rs |  18 ++-
 src/xs.rs   | 321 ++++++++++------------------------------------------
 4 files changed, 100 insertions(+), 265 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index a60ef1461c84..1b05dac89671 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -165,6 +165,18 @@ dependencies = [
  "autocfg",
 ]
 
+[[package]]
+name = "nix"
+version = "0.24.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "195cdbc1741b8134346d515b3a56a1c94b0912758009cfd53f99ea0f57b065fc"
+dependencies = [
+ "bitflags",
+ "cfg-if",
+ "libc",
+ "memoffset",
+]
+
 [[package]]
 name = "once_cell"
 version = "1.13.0"
@@ -437,9 +449,19 @@ checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 [[package]]
 name = "xen-ioctls"
 version = "0.0.0-pre1"
-source = "git+https://gitlab.com/mathieupoirier/oxerun/?branch=xen-ioctls#2774d5ad0ac9a2dfca768df761f80679d2ddd3e7"
+source = "git+https://gitlab.com/mathieupoirier/oxerun/?branch=xen-ioctls#3ea1fc6e67486460976d90705c97422fd0533e2c"
+dependencies = [
+ "libc",
+ "vmm-sys-util",
+]
+
+[[package]]
+name = "xen-store"
+version = "0.0.0-pre1"
+source = "git+https://gitlab.com/mathieupoirier/oxerun/?branch=xen-ioctls#3ea1fc6e67486460976d90705c97422fd0533e2c"
 dependencies = [
  "libc",
+ "nix",
  "vmm-sys-util",
 ]
 
@@ -460,4 +482,5 @@ dependencies = [
  "vm-memory",
  "vmm-sys-util",
  "xen-ioctls",
+ "xen-store",
 ]
diff --git a/Cargo.toml b/Cargo.toml
index e4620fa22513..2d6a5be01f62 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -23,3 +23,4 @@ virtio-queue = "0.5"
 vm-memory = { version = ">=0.8.0", features = ["backend-mmap", "backend-atomic", "backend-bitmap"] }
 vmm-sys-util = "=0.10.0"
 xen-ioctls = { git = "https://gitlab.com/mathieupoirier/oxerun/", branch = "xen-ioctls" }
+xen-store = { git = "https://gitlab.com/mathieupoirier/oxerun/", branch = "xen-ioctls" }
diff --git a/src/main.rs b/src/main.rs
index c8aafc21439f..6b34be7463f6 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -14,6 +14,7 @@ mod xs;
 use clap::Parser;
 use seccompiler::SeccompAction;
 use std::{
+    convert::TryInto,
     io,
     num::ParseIntError,
     str,
@@ -38,7 +39,7 @@ use xdm::XenDeviceModel;
 use xec::XenEventChannel;
 use xfm::XenForeignMemory;
 use xgm::XenGuestMem;
-use xs::{XsDev, XsReadWatch};
+use xs::XsDev;
 
 /// Result for xen-vhost-master operations
 pub type Result<T> = std::result::Result<T, Error>;
@@ -226,12 +227,19 @@ impl XenState {
     }
 
     fn handle_xen_store_event(&mut self) -> Result<()> {
-        let watch = XsReadWatch::new(&self.xsd)?;
-        let name = watch.data(xs_watch_type_XS_WATCH_TOKEN)?;
+        let name = match self
+            .xsd
+            .read_watch(xs_watch_type_XS_WATCH_TOKEN.try_into().unwrap())
+        {
+            Ok(watch) => watch,
+            Err(_) => {
+                return Err(Error::XsWatchFailed);
+            }
+        };
 
-        if self.xsd.be().eq(name) {
+        if self.xsd.be().eq(&name) {
             self.handle_be_state_change()
-        } else if self.xsd.fe().eq(name) {
+        } else if self.xsd.fe().eq(&name) {
             self.handle_fe_state_change()
         } else {
             Ok(())
diff --git a/src/xs.rs b/src/xs.rs
index a4c4fd02a2df..cf780bf02c79 100644
--- a/src/xs.rs
+++ b/src/xs.rs
@@ -3,204 +3,37 @@
 //
 // SPDX-License-Identifier: Apache-2.0
 
-use libc::free;
-use std::ffi::{CStr, CString};
 use std::io;
-use std::os::raw::{c_char, c_void};
-use std::{slice, str, thread, time};
+use std::{str, thread, time};
 
 use vmm_sys_util::epoll::{ControlOperation, Epoll, EpollEvent, EventSet};
 
 use super::{Error, Result};
+
 use libxen_sys::{
-    domid_t, strlen, xenbus_state_XenbusStateInitWait, xenbus_state_XenbusStateInitialising,
-    xenbus_state_XenbusStateUnknown, xs_close, xs_directory, xs_fileno, xs_handle, xs_open,
-    xs_read, xs_read_watch, xs_transaction_t, xs_watch, xs_watch_type, xs_watch_type_XS_WATCH_PATH,
-    xs_write, XenbusState, XBT_NULL,
+    xenbus_state_XenbusStateInitWait, xenbus_state_XenbusStateInitialising,
+    xenbus_state_XenbusStateUnknown, xs_watch_type_XS_WATCH_PATH, XBT_NULL,
 };
 
-struct XsWatch {
-    _xsh: *mut xs_handle,
-    _path: CString,
-    _token: CString,
-}
-
-impl XsWatch {
-    fn new(dev: &XsDev, path: CString, token: CString) -> Result<Self> {
-        let ret = unsafe { xs_watch(dev.xsh(), path.as_ptr(), token.as_ptr()) };
-
-        if !ret {
-            return Err(Error::XsWatchFailed);
-        }
-
-        Ok(Self {
-            _xsh: dev.xsh(),
-            _path: path,
-            _token: token,
-        })
-    }
-}
-
-impl Drop for XsWatch {
-    fn drop(&mut self) {
-        // FIXME
-        //
-        // If the guest goes away first, this just hangs and the xen-vhost-master daemon never
-        // exits. Comment out the code for now.
-        //
-        // unsafe {
-        //     xs_unwatch(self.xsh, self.path.as_ptr(), self.token.as_ptr());
-        // }
-    }
-}
-
-pub struct XsReadWatch {
-    buf: *mut *mut c_char,
-    num: u32,
-}
-
-impl XsReadWatch {
-    pub fn new(dev: &XsDev) -> Result<Self> {
-        let mut num: u32 = 0;
-        let buf = unsafe { xs_read_watch(dev.xsh, &mut num) };
-        if buf.is_null() {
-            return Err(Error::XsError);
-        }
-
-        Ok(Self { buf, num })
-    }
-
-    pub fn buf(&self) -> *mut *mut c_char {
-        self.buf
-    }
-
-    pub fn num(&self) -> u32 {
-        self.num
-    }
-
-    pub fn data(&self, index: xs_watch_type) -> Result<&str> {
-        // SAFETY: The array is guaranteed to be valid here.
-        let vec = unsafe { slice::from_raw_parts(self.buf(), self.num() as usize) };
-
-        // SAFETY: The string is guaranteed to be valid here.
-        let path = str::from_utf8(unsafe {
-            slice::from_raw_parts(
-                vec[index as usize] as *const u8,
-                strlen(vec[index as usize] as *const u8) as usize,
-            )
-        })
-        .map_err(Error::InvalidString)?;
-
-        Ok(path)
-    }
-}
-
-impl Drop for XsReadWatch {
-    fn drop(&mut self) {
-        unsafe { free(self.buf as *mut c_void) }
-    }
-}
-
-struct XsDirectory {
-    buf: *mut *mut c_char,
-    num: u32,
-}
-
-impl XsDirectory {
-    pub fn new(dev: &XsDev, path: &CStr) -> Result<Self> {
-        let mut num: u32 = 0;
-        let buf = unsafe { xs_directory(dev.xsh, XBT_NULL, path.as_ptr(), &mut num) };
-        if buf.is_null() {
-            return Err(Error::XsDirectoryFailed);
-        }
-
-        Ok(Self { buf, num })
-    }
-
-    pub fn num(&self) -> u32 {
-        self.num
-    }
-
-    pub fn entries(&self) -> Result<Vec<i32>> {
-        let mut values = Vec::new();
-
-        // SAFETY: The string is guaranteed to be valid here.
-        let entries =
-            unsafe { slice::from_raw_parts(self.buf as *mut *mut c_char, self.num as usize) };
-
-        for entry in entries {
-            // SAFETY: The string is guaranteed to be valid here.
-            let buf = str::from_utf8(unsafe {
-                slice::from_raw_parts(*entry as *const u8, strlen(*entry as *const u8) as usize)
-            })
-            .map_err(Error::InvalidString)?;
-
-            values.push(buf.parse::<i32>().map_err(Error::ParseFailure)?);
-        }
-
-        Ok(values)
-    }
-}
-
-impl Drop for XsDirectory {
-    fn drop(&mut self) {
-        unsafe { free(self.buf as *mut c_void) }
-    }
-}
-
-struct XsRead {
-    buf: *mut c_void,
-    len: u32,
-}
-
-impl XsRead {
-    pub fn new(dev: &XsDev, transaction: xs_transaction_t, path: &CStr) -> Result<Self> {
-        let mut len: u32 = 0;
-        let buf = unsafe { xs_read(dev.xsh, transaction, path.as_ptr(), &mut len) };
-        if buf.is_null() {
-            return Err(Error::XsReadFailed);
-        }
-
-        Ok(Self { buf, len })
-    }
-
-    pub fn buf(&self) -> *mut c_void {
-        self.buf
-    }
-
-    pub fn len(&self) -> u32 {
-        self.len
-    }
-}
-
-impl Drop for XsRead {
-    fn drop(&mut self) {
-        unsafe { free(self.buf) }
-    }
-}
+use xen_store::XenStoreHandle;
 
 pub struct XsDev {
-    xsh: *mut xs_handle,
-    be_domid: domid_t,
-    fe_domid: domid_t,
+    xsh: XenStoreHandle,
+    be_domid: u16,
+    fe_domid: u16,
     dev_id: i32,
     dev_name: String,
     be: String,
     fe: String,
     be_state: u32,
-    path: CString,
+    path: String,
     addr: u32,
     irq: u8,
-    be_watch: Option<XsWatch>,
-    fe_watch: Option<XsWatch>,
 }
 
 impl XsDev {
     pub fn new(dev_name: String) -> Result<Self> {
-        let xsh = unsafe { xs_open(0) };
-        if xsh.is_null() {
-            return Err(Error::XsOpenFailed);
-        }
+        let xsh = XenStoreHandle::new().map_err(Error::XenIoctlError)?;
 
         Ok(Self {
             xsh,
@@ -211,23 +44,17 @@ impl XsDev {
             be: "".to_string(),
             fe: "".to_string(),
             be_state: 0,
-            path: CString::new(format!("backend/{}", dev_name)).unwrap(),
+            path: format!("backend/{}", dev_name),
             addr: 0,
             irq: 0,
-            be_watch: None,
-            fe_watch: None,
         })
     }
 
-    pub fn xsh(&self) -> *mut xs_handle {
-        self.xsh
-    }
-
-    pub fn be_domid(&self) -> domid_t {
+    pub fn be_domid(&self) -> u16 {
         self.be_domid
     }
 
-    pub fn fe_domid(&self) -> domid_t {
+    pub fn fe_domid(&self) -> u16 {
         self.fe_domid
     }
 
@@ -247,42 +74,18 @@ impl XsDev {
         &self.fe
     }
 
-    pub fn read_str_raw(&self, transaction: xs_transaction_t, path: &CStr) -> Result<String> {
-        let read = XsRead::new(self, transaction, path)?;
-
-        // SAFETY: The string is guaranteed to be valid here.
-        let val = str::from_utf8(unsafe {
-            slice::from_raw_parts(read.buf() as *const u8, read.len() as usize)
-        })
-        .map_err(Error::InvalidString)?;
-
-        let val = val.to_string();
-
-        Ok(val)
+    pub fn read_str_raw(&self, _transaction: u32, path: &str) -> Result<String> {
+        self.xsh.read_str(path).map_err(Error::XenIoctlError)
     }
 
     pub fn read_str(&self, base: &str, node: &str) -> Result<String> {
-        let path = CString::new(format!("{}/{}", base, node)).unwrap();
-
-        self.read_str_raw(0, &path)
+        self.read_str_raw(0, format!("{}/{}", base, node).as_str())
     }
 
     pub fn write_str(&self, base: &str, node: &str, val: &str) -> Result<()> {
-        let path = CString::new(format!("{}/{}", base, node)).unwrap();
-        let val = CString::new(val).unwrap();
-
-        match unsafe {
-            xs_write(
-                self.xsh,
-                0,
-                path.as_ptr(),
-                val.as_ptr() as *const c_void,
-                strlen(val.as_ptr()) as u32,
-            )
-        } {
-            true => Ok(()),
-            false => Err(Error::XsError),
-        }
+        self.xsh
+            .write_str(format!("{}/{}", base, node).as_str(), val)
+            .map_err(|_| Error::XsError)
     }
 
     pub fn read_be_str(&self, node: &str) -> Result<String> {
@@ -312,22 +115,17 @@ impl XsDev {
         self.write_int(&self.be, node, val)
     }
 
-    pub fn set_be_state(&mut self, state: XenbusState) -> Result<()> {
+    pub fn set_be_state(&mut self, state: u32) -> Result<()> {
         self.write_be_int("state", state)?;
         self.be_state = state;
         Ok(())
     }
 
     pub fn fileno(&self) -> Result<i32> {
-        let fd = unsafe { xs_fileno(self.xsh) };
-        if fd < 0 {
-            Err(Error::FileOpenFailed)
-        } else {
-            Ok(fd)
-        }
+        self.xsh.fileno().map_err(|_| Error::FileOpenFailed)
     }
 
-    pub fn wait_be_state(&self, state: XenbusState) -> Result<u32> {
+    pub fn wait_be_state(&self, state: u32) -> Result<u32> {
         let state = state | 1 << xenbus_state_XenbusStateUnknown;
 
         loop {
@@ -337,32 +135,31 @@ impl XsDev {
                 return Ok(val);
             }
 
-            XsReadWatch::new(self)?;
+            let _ = self.read_watch(0).map_err(|_| Error::XsReadFailed);
         }
     }
 
     pub fn get_be_domid(&mut self) -> Result<()> {
-        let name = CString::new("domid").unwrap();
-
-        let id = self.read_str_raw(XBT_NULL, &name)?;
+        let id = self.read_str_raw(XBT_NULL, "domid")?;
         self.be_domid = id.parse::<u16>().map_err(Error::ParseFailure)?;
 
         Ok(())
     }
 
     fn update_fe_domid(&mut self) -> Result<()> {
-        let watch = XsReadWatch::new(self)?;
-        if !self
-            .path
-            .eq(&CString::new(watch.data(xs_watch_type_XS_WATCH_PATH)?).unwrap())
-        {
+        let name = self.read_watch(xs_watch_type_XS_WATCH_PATH as usize)?;
+        if !self.path.eq(&name) {
             return Err(Error::XsError);
         }
 
-        let directory = XsDirectory::new(self, &self.path)?;
-        let values = directory.entries()?;
+        let directory = match self.xsh.directory(&self.path) {
+            Ok(directory) => directory,
+            Err(_) => {
+                return Err(Error::XsDirectoryFailed);
+            }
+        };
 
-        for id in values {
+        for id in directory {
             if id as u16 > self.fe_domid {
                 self.fe_domid = id as u16;
             }
@@ -377,24 +174,29 @@ impl XsDev {
         // guarantee that.
         thread::sleep(time::Duration::from_millis(200));
 
-        let path = CString::new(format!("backend/{}/{}", self.dev_name, self.fe_domid)).unwrap();
+        let path = format!("backend/{}/{}", self.dev_name, self.fe_domid);
+        let directory = match self.xsh.directory(path.as_str()) {
+            Ok(directory) => directory,
+            Err(_) => return Err(Error::XsDirectoryFailed),
+        };
 
-        let directory = XsDirectory::new(self, &path)?;
-        if directory.num() > 1 {
+        if directory.len() > 1 {
             println!(
                 "got {} devices, but only single device is supported\n",
-                directory.num(),
+                directory.len(),
             );
         }
 
-        self.dev_id = directory.entries()?[0];
+        self.dev_id = directory[0];
 
-        let path = CString::new(format!(
-            "/local/domain/{}/device/{}/{}",
-            self.fe_domid, self.dev_name, self.dev_id,
-        ))
-        .unwrap();
-        match self.read_str_raw(XBT_NULL, &path) {
+        match self.read_str_raw(
+            XBT_NULL,
+            format!(
+                "/local/domain/{}/device/{}/{}",
+                self.fe_domid, self.dev_name, self.dev_id,
+            )
+            .as_str(),
+        ) {
             Ok(_) => Ok(()),
             Err(e) => {
                 self.dev_id = 0;
@@ -404,7 +206,7 @@ impl XsDev {
     }
 
     pub fn get_fe_domid(&mut self) -> Result<()> {
-        let _watch = XsWatch::new(self, self.path.clone(), self.path.clone())?;
+        self.create_watch(self.path.clone(), self.path.clone())?;
 
         loop {
             let fd = self.fileno()?;
@@ -447,6 +249,16 @@ impl XsDev {
         }
     }
 
+    pub fn create_watch(&mut self, path: String, token: String) -> Result<()> {
+        self.xsh
+            .create_watch(path.as_str(), token.as_str())
+            .map_err(|_| Error::XsWatchFailed)
+    }
+
+    pub fn read_watch(&self, index: usize) -> Result<String> {
+        self.xsh.read_watch(index).map_err(|_| Error::XsWatchFailed)
+    }
+
     pub fn connect_dom(&mut self) -> Result<()> {
         // Update be path
         self.be = format!(
@@ -467,11 +279,8 @@ impl XsDev {
             return Err(Error::XsInvalidState);
         }
 
-        let be = CString::new(self.be.clone()).unwrap();
-        self.be_watch = Some(XsWatch::new(self, be.clone(), be)?);
-
-        let fe = CString::new(self.fe.clone()).unwrap();
-        self.fe_watch = Some(XsWatch::new(self, fe.clone(), fe)?);
+        self.create_watch(self.be.clone(), self.be.clone())?;
+        self.create_watch(self.fe.clone(), self.fe.clone())?;
 
         let state = self.wait_be_state(1 << xenbus_state_XenbusStateInitWait)?;
         if state != xenbus_state_XenbusStateInitWait {
@@ -484,9 +293,3 @@ impl XsDev {
         Ok(())
     }
 }
-
-impl Drop for XsDev {
-    fn drop(&mut self) {
-        unsafe { xs_close(self.xsh) }
-    }
-}
-- 
2.25.1

