From vireshk  Fri Jun 24 07:58:50 2016
Delivered-To: viresh.kumar@linaro.org
Received: from gmail-pop.l.google.com [74.125.200.109] 	by vireshk-i7 with POP3 (fetchmail-6.3.26) 	for <vireshk@localhost> (single-drop); Fri, 24 Jun 2016 07:58:50 +0530 (IST)
Received: by 10.200.49.53 with SMTP id g50csp805299qtb;         Thu, 23 Jun 2016 18:54:47 -0700 (PDT)
X-Received: by 10.66.165.40 with SMTP id yv8mr2954563pab.89.1466733287875;         Thu, 23 Jun 2016 18:54:47 -0700 (PDT)
Return-Path: <jcarlyle@google.com>
Received: from mail-pa0-x22a.google.com (mail-pa0-x22a.google.com. [2607:f8b0:400e:c03::22a])         by mx.google.com with ESMTPS id vw6si3403535pac.113.2016.06.23.18.54.47         for <viresh.kumar@linaro.org>         (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);         Thu, 23 Jun 2016 18:54:47 -0700 (PDT)
Received-SPF: pass (google.com: domain of jcarlyle@google.com designates 2607:f8b0:400e:c03::22a as permitted sender) client-ip=2607:f8b0:400e:c03::22a;
Authentication-Results: mx.google.com;        dkim=pass header.i=@google.com;        spf=pass (google.com: domain of jcarlyle@google.com designates 2607:f8b0:400e:c03::22a as permitted sender) smtp.mailfrom=jcarlyle@google.com;        dmarc=pass (p=REJECT dis=NONE) header.from=google.com
Received: by mail-pa0-x22a.google.com with SMTP id bz2so32547120pad.1         for <viresh.kumar@linaro.org>; Thu, 23 Jun 2016 18:54:47 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;         d=google.com; s=20120113;         h=from:to:cc:subject:date:message-id;         bh=ynxEq1cvOiGS/SaOKJsCscFVenH5zjCMzpVRzB0N1eg=;         b=RJIWXe2OXPPWjGKWuU6CktwH6kEOsOSro/frfx2mklMiIe0L4Vp9mxKk8jHxTO8F7b          8FjJk+Nr9WdlkZU+uGaBqdsG1CwcDKXwOkC0ecIcbOl9n1VDP4Tsscxa2tv/pl+QAw41          PuWZg3JdLe47Ds3pymyNgS6SvsSl9WEM3KjU6Xmg2cDCDXsehAoYYe0uO7mM2cM1/3hY          gOFFBMPgcR/SggfbydRplYK5FWYx28ST044z+97ZG9YCmPXORTfsU4u5YZ3EFMn9WgE0          HDkLtf0BTpjTN1bPmlfrOMVyH8vvxNaf8yCa5LfUj16pK/1PdqkdT/SpHZhk2BfcR75z          O/cA==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;         d=1e100.net; s=20130820;         h=x-gm-message-state:from:to:cc:subject:date:message-id;         bh=ynxEq1cvOiGS/SaOKJsCscFVenH5zjCMzpVRzB0N1eg=;         b=Qr9fQtH+cxYnuAvxB1nVRMFKdXeKhB2PDI2cQeG0GbbKoPCB76Bccn7xb+HtIM7cpL          x1aOJK6klq7e0qEVFI117lbhKx2o8yh/dKI6cPLmkLtD4rLZyKgTOSv7NDafLZDJ+lIs          OyEGMcYj0AnHKyOsl9w2ifcdj63Khi/GQuWdyiwojP1XzfxbdvxUHyhPjsM9KEUiTnoF          TE4IYT01JIiFacdme5tADX668j4khCs4DRxBP5lfRpFzYpUrCNGLqaF1wkMHqgxE+emV          4vuZ72LSvnAU1pIIpPSRlzZdIlPawlXWFH31LuM2xcB4VSdT2b6XtST07+itq8mmByBe          /UYw==
X-Gm-Message-State: ALyK8tJvz6TjLjFZLPJ/PQM2qc/UkMBLudTwBuLWMVdxzVRTY3+K73aoyb1+1rJWJhxrCoHE
X-Received: by 10.66.157.8 with SMTP id wi8mr2907737pab.21.1466733287290;         Thu, 23 Jun 2016 18:54:47 -0700 (PDT)
Return-Path: <jcarlyle@google.com>
Received: from localhost ([2620:0:1000:6509:b584:d622:23c:42a0])         by smtp.gmail.com with ESMTPSA id t4sm2904660paf.39.2016.06.23.18.54.46         (version=TLS1_2 cipher=AES128-SHA bits=128/128);         Thu, 23 Jun 2016 18:54:46 -0700 (PDT)
From: Jeffrey Carlyle <jcarlyle@google.com>
To: project-ara-kernel@lists.linaro.org, 	gregkh@google.com, 	viresh.kumar@linaro.org
Cc: Jeffrey Carlyle <jcarlyle@google.com>
Subject: [PATCH] SW-6595: connection: switch to using spin_lock_irqsave/spin_lock_irqrestore excluisvely
Date: Thu, 23 Jun 2016 18:54:32 -0700
Message-Id: <1466733272-138825-1-git-send-email-jcarlyle@google.com>
X-Mailer: git-send-email 2.8.0.rc3.226.g39d4020
Content-Length: 6773
Lines: 191

We know that it is a bad idea to explicitly enable IRQs when we don't
don't know if they were already off before we disabled, so switch to the
save _irqsave and _irqrestore functions.

Ultimately, we need to review places in the Greybus drivers where IRQs
are disabled and remove unnecessary instances. This is only an interim
step.

Testing done: booted EVT2.0, ran suspend/resume test app with a period
of 20s for a few dozen cycles.

Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
Signed-off-by: Jeffrey Carlyle <jcarlyle@google.com>
---
 connection.c | 51 +++++++++++++++++++++++++++++----------------------
 1 file changed, 29 insertions(+), 22 deletions(-)

diff --git a/connection.c b/connection.c
index 810c618..e78d18d 100644
--- a/connection.c
+++ b/connection.c
@@ -572,7 +572,7 @@ static int gb_connection_ping(struct gb_connection *connection)
  * DISCONNECTING.
  */
 static void gb_connection_cancel_operations(struct gb_connection *connection,
-						int errno)
+						int errno, unsigned long *flags)
 	__must_hold(&connection->lock)
 {
 	struct gb_operation *operation;
@@ -581,7 +581,7 @@ static void gb_connection_cancel_operations(struct gb_connection *connection,
 		operation = list_last_entry(&connection->operations,
 						struct gb_operation, links);
 		gb_operation_get(operation);
-		spin_unlock_irq(&connection->lock);
+		spin_unlock_irqrestore(&connection->lock, *flags);
 
 		if (gb_operation_is_incoming(operation))
 			gb_operation_cancel_incoming(operation, errno);
@@ -590,7 +590,7 @@ static void gb_connection_cancel_operations(struct gb_connection *connection,
 
 		gb_operation_put(operation);
 
-		spin_lock_irq(&connection->lock);
+		spin_lock_irqsave(&connection->lock, *flags);
 	}
 }
 
@@ -601,7 +601,7 @@ static void gb_connection_cancel_operations(struct gb_connection *connection,
  */
 static void
 gb_connection_flush_incoming_operations(struct gb_connection *connection,
-						int errno)
+						int errno, unsigned long *flags)
 	__must_hold(&connection->lock)
 {
 	struct gb_operation *operation;
@@ -621,13 +621,13 @@ gb_connection_flush_incoming_operations(struct gb_connection *connection,
 		if (!incoming)
 			break;
 
-		spin_unlock_irq(&connection->lock);
+		spin_unlock_irqrestore(&connection->lock, *flags);
 
 		/* FIXME: flush, not cancel? */
 		gb_operation_cancel_incoming(operation, errno);
 		gb_operation_put(operation);
 
-		spin_lock_irq(&connection->lock);
+		spin_lock_irqsave(&connection->lock, *flags);
 	}
 }
 
@@ -644,15 +644,16 @@ gb_connection_flush_incoming_operations(struct gb_connection *connection,
 static int _gb_connection_enable(struct gb_connection *connection, bool rx)
 {
 	int ret;
+	unsigned long flags;
 
 	/* Handle ENABLED_TX -> ENABLED transitions. */
 	if (connection->state == GB_CONNECTION_STATE_ENABLED_TX) {
 		if (!(connection->handler && rx))
 			return 0;
 
-		spin_lock_irq(&connection->lock);
+		spin_lock_irqsave(&connection->lock, flags);
 		connection->state = GB_CONNECTION_STATE_ENABLED;
-		spin_unlock_irq(&connection->lock);
+		spin_unlock_irqrestore(&connection->lock, flags);
 
 		return 0;
 	}
@@ -669,12 +670,12 @@ static int _gb_connection_enable(struct gb_connection *connection, bool rx)
 	if (ret)
 		goto err_svc_connection_destroy;
 
-	spin_lock_irq(&connection->lock);
+	spin_lock_irqsave(&connection->lock, flags);
 	if (connection->handler && rx)
 		connection->state = GB_CONNECTION_STATE_ENABLED;
 	else
 		connection->state = GB_CONNECTION_STATE_ENABLED_TX;
-	spin_unlock_irq(&connection->lock);
+	spin_unlock_irqrestore(&connection->lock, flags);
 
 	ret = gb_connection_control_connected(connection);
 	if (ret)
@@ -685,10 +686,10 @@ static int _gb_connection_enable(struct gb_connection *connection, bool rx)
 err_control_disconnecting:
 	gb_connection_control_disconnecting(connection);
 
-	spin_lock_irq(&connection->lock);
+	spin_lock_irqsave(&connection->lock, flags);
 	connection->state = GB_CONNECTION_STATE_DISCONNECTING;
-	gb_connection_cancel_operations(connection, -ESHUTDOWN);
-	spin_unlock_irq(&connection->lock);
+	gb_connection_cancel_operations(connection, -ESHUTDOWN, &flags);
+	spin_unlock_irqrestore(&connection->lock, flags);
 
 	/* Transmit queue should already be empty. */
 	gb_connection_hd_cport_flush(connection);
@@ -754,16 +755,18 @@ EXPORT_SYMBOL_GPL(gb_connection_enable_tx);
 
 void gb_connection_disable_rx(struct gb_connection *connection)
 {
+	unsigned long flags;
+
 	mutex_lock(&connection->mutex);
 
-	spin_lock_irq(&connection->lock);
+	spin_lock_irqsave(&connection->lock, flags);
 	if (connection->state != GB_CONNECTION_STATE_ENABLED) {
 		spin_unlock_irq(&connection->lock);
 		goto out_unlock;
 	}
 	connection->state = GB_CONNECTION_STATE_ENABLED_TX;
-	gb_connection_flush_incoming_operations(connection, -ESHUTDOWN);
-	spin_unlock_irq(&connection->lock);
+	gb_connection_flush_incoming_operations(connection, -ESHUTDOWN, &flags);
+	spin_unlock_irqrestore(&connection->lock, flags);
 
 	trace_gb_connection_disable(connection);
 
@@ -786,6 +789,8 @@ void gb_connection_mode_switch_complete(struct gb_connection *connection)
 
 void gb_connection_disable(struct gb_connection *connection)
 {
+	unsigned long flags;
+
 	mutex_lock(&connection->mutex);
 
 	if (connection->state == GB_CONNECTION_STATE_DISABLED)
@@ -795,10 +800,10 @@ void gb_connection_disable(struct gb_connection *connection)
 
 	gb_connection_control_disconnecting(connection);
 
-	spin_lock_irq(&connection->lock);
+	spin_lock_irqsave(&connection->lock, flags);
 	connection->state = GB_CONNECTION_STATE_DISCONNECTING;
-	gb_connection_cancel_operations(connection, -ESHUTDOWN);
-	spin_unlock_irq(&connection->lock);
+	gb_connection_cancel_operations(connection, -ESHUTDOWN, &flags);
+	spin_unlock_irqrestore(&connection->lock, flags);
 
 	gb_connection_hd_cport_flush(connection);
 
@@ -825,6 +830,8 @@ EXPORT_SYMBOL_GPL(gb_connection_disable);
 /* Disable a connection without communicating with the remote end. */
 void gb_connection_disable_forced(struct gb_connection *connection)
 {
+	unsigned long flags;
+
 	mutex_lock(&connection->mutex);
 
 	if (connection->state == GB_CONNECTION_STATE_DISABLED)
@@ -832,10 +839,10 @@ void gb_connection_disable_forced(struct gb_connection *connection)
 
 	trace_gb_connection_disable(connection);
 
-	spin_lock_irq(&connection->lock);
+	spin_lock_irqsave(&connection->lock, flags);
 	connection->state = GB_CONNECTION_STATE_DISABLED;
-	gb_connection_cancel_operations(connection, -ESHUTDOWN);
-	spin_unlock_irq(&connection->lock);
+	gb_connection_cancel_operations(connection, -ESHUTDOWN, &flags);
+	spin_unlock_irqrestore(&connection->lock, flags);
 
 	gb_connection_hd_cport_flush(connection);
 	gb_connection_hd_cport_features_disable(connection);
-- 
2.8.0.rc3.226.g39d4020

