From vireshk  Fri Mar 17 08:12:13 2017
Delivered-To: viresh.kumar@linaro.org
Received: from gmail-pop.l.google.com [74.125.130.108] 	by vireshk-i7 with POP3 (fetchmail-6.3.26) 	for <vireshk@localhost> (single-drop); Fri, 17 Mar 2017 08:12:13 +0530 (IST)
Received: by 10.36.254.201 with SMTP id w192csp37836ith;         Thu, 16 Mar 2017 15:47:53 -0700 (PDT)
X-Received: by 10.46.7.80 with SMTP id i16mr3856591ljd.129.1489704473094;         Thu, 16 Mar 2017 15:47:53 -0700 (PDT)
Return-Path: <rjw@rjwysocki.net>
Received: from cloudserver094114.home.net.pl (cloudserver094114.home.net.pl. [79.96.170.134])         by mx.google.com with ESMTPS id q65si3438122ljb.236.2017.03.16.15.47.52         for <viresh.kumar@linaro.org>         (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);         Thu, 16 Mar 2017 15:47:52 -0700 (PDT)
Received-SPF: pass (google.com: domain of rjw@rjwysocki.net designates 79.96.170.134 as permitted sender) client-ip=79.96.170.134;
Authentication-Results: mx.google.com;        spf=pass (google.com: domain of rjw@rjwysocki.net designates 79.96.170.134 as permitted sender) smtp.mailfrom=rjw@rjwysocki.net
Return-Path: <rjw@rjwysocki.net>
Received: from adks173.ipv4.supernova.orange.pl (79.184.252.173) (HELO aspire.rjw.lan)  by serwer1319399.home.pl (79.96.170.134) with SMTP (IdeaSmtpServer 0.81.2)  id be7e9ff2fa17e665; Thu, 16 Mar 2017 23:47:54 +0100
From: "Rafael J. Wysocki" <rjw@rjwysocki.net>
To: Linux PM <linux-pm@vger.kernel.org>
Cc: LKML <linux-kernel@vger.kernel.org>, Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>, Viresh Kumar <viresh.kumar@linaro.org>
Subject: [PATCH] cpufreq: Restore policy min/max limits on CPU online
Date: Thu, 16 Mar 2017 23:42:23 +0100
Message-ID: <2084010.4xkKok06Gp@aspire.rjw.lan>
User-Agent: KMail/4.14.10 (Linux/4.10.0+; KDE/4.14.9; x86_64; ; )
MIME-Version: 1.0
Content-Transfer-Encoding: 7Bit
Content-Type: text/plain; charset="us-ascii"
Status: RO
X-Status: A
Content-Length: 1857
Lines: 47

From: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

On CPU online the cpufreq core restores the previous governor (or
the previous "policy" setting for ->setpolicy drivers), but it does
not restore the min/max limits at the same time, which is confusing,
inconsistent and real pain for users who set the limits and then
suspend/resume the system (using full suspend), in which case the
limits are reset on all CPUs except for the boot one.

Fix this by making cpufreq_init_policy() restore the limits when it
sees that this is CPU online and not initialization from scratch.

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
---
 drivers/cpufreq/cpufreq.c |    9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

Index: linux-pm/drivers/cpufreq/cpufreq.c
===================================================================
--- linux-pm.orig/drivers/cpufreq/cpufreq.c
+++ linux-pm/drivers/cpufreq/cpufreq.c
@@ -979,6 +979,8 @@ static int cpufreq_init_policy(struct cp
 	/* Update governor of new_policy to the governor used before hotplug */
 	gov = find_governor(policy->last_governor);
 	if (gov) {
+		new_policy.min = policy->user_policy.min;
+		new_policy.max = policy->user_policy.max;
 		pr_debug("Restoring governor %s for cpu %d\n",
 				policy->governor->name, policy->cpu);
 	} else {
@@ -991,11 +993,14 @@ static int cpufreq_init_policy(struct cp
 
 	/* Use the default policy if there is no last_policy. */
 	if (cpufreq_driver->setpolicy) {
-		if (policy->last_policy)
+		if (policy->last_policy) {
 			new_policy.policy = policy->last_policy;
-		else
+			new_policy.min = policy->user_policy.min;
+			new_policy.max = policy->user_policy.max;
+		} else {
 			cpufreq_parse_governor(gov->name, &new_policy.policy,
 					       NULL);
+		}
 	}
 	/* set default policy */
 	return cpufreq_set_policy(policy, &new_policy);

