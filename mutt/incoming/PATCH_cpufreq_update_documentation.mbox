From claudio@evidence.eu.com  Thu Jan  5 09:04:13 2017
From: Claudio Scordino <claudio@evidence.eu.com>
Date: Thu, 22 Dec 2016 08:38:15 +0100
Subject: [PATCH] cpufreq: update documentation

Signed-off-by: Claudio Scordino <claudio@evidence.eu.com>
---
 Documentation/cpu-freq/core.txt      |  8 ++--
 Documentation/cpu-freq/governors.txt | 83 +++++++++++++++++++-----------------
 include/linux/cpufreq.h              |  2 +-
 3 files changed, 49 insertions(+), 44 deletions(-)

diff --git a/Documentation/cpu-freq/core.txt b/Documentation/cpu-freq/core.txt
index 4bc7287..b80075e 100644
--- a/Documentation/cpu-freq/core.txt
+++ b/Documentation/cpu-freq/core.txt
@@ -69,11 +69,9 @@ CPUFreq policy notifier is called twice for a policy transition:
 The phase is specified in the second argument to the notifier.

 The third argument, a void *pointer, points to a struct cpufreq_policy
-consisting of five values: cpu, min, max, policy and max_cpu_freq. min
-and max are the lower and upper frequencies (in kHz) of the new
-policy, policy the new policy, cpu the number of the affected CPU; and
-max_cpu_freq the maximum supported CPU frequency. This value is given
-for informational purposes only.
+consisting of several values, including min, max, policy and cpu.
+min and max are the lower and upper frequencies (in kHz) of the new policy,
+policy the new policy, and cpu the number of the affected CPU.


 2.2 CPUFreq transition notifiers
diff --git a/Documentation/cpu-freq/governors.txt
b/Documentation/cpu-freq/governors.txt
index c15aa75..2610bb3 100644
--- a/Documentation/cpu-freq/governors.txt
+++ b/Documentation/cpu-freq/governors.txt
@@ -28,9 +28,11 @@ Contents:
 2.3  Userspace
 2.4  Ondemand
 2.5  Conservative
+2.6  Schedutil

 3.   The Governor Interface in the CPUfreq Core

+4.   References


 1. What Is A CPUFreq Governor?
@@ -45,15 +47,7 @@ call instead of the existing "->setpolicy" call. For "longrun", all
 stays the same, though.

 How to decide what frequency within the CPUfreq policy should be used?
-That's done using "cpufreq governors". Two are already in this patch
--- they're the already existing "powersave" and "performance" which
-set the frequency statically to the lowest or highest frequency,
-respectively. At least two more such governors will be ready for
-addition in the near future, but likely many more as there are various
-different theories and models about dynamic frequency scaling
-around. Using such a generic interface as cpufreq offers to scaling
-governors, these can be tested extensively, and the best one can be
-selected for each specific use.
+That's done using "cpufreq governors".

 Basically, it's the following flow graph:

@@ -84,7 +78,7 @@ CPU can be set to switch independently |   CPU can only be set
 2.1 Performance
 ---------------

-The CPUfreq governor "performance" sets the CPU statically to the
+This is a trivial governor that sets the CPU statically to the
 highest frequency within the borders of scaling_min_freq and
 scaling_max_freq.

@@ -92,7 +86,7 @@ scaling_max_freq.
 2.2 Powersave
 -------------

-The CPUfreq governor "powersave" sets the CPU statically to the
+This is a trivial governor that sets the CPU statically to the
 lowest frequency within the borders of scaling_min_freq and
 scaling_max_freq.

@@ -100,7 +94,7 @@ scaling_max_freq.
 2.3 Userspace
 -------------

-The CPUfreq governor "userspace" allows the user, or any userspace
+This is a trivial governor that allows the user, or any userspace
 program running with UID "root", to set the CPU to a specific frequency
 by making a sysfs file "scaling_setspeed" available in the CPU-device
 directory.
@@ -109,10 +103,12 @@ directory.
 2.4 Ondemand
 ------------

-The CPUfreq governor "ondemand" sets the CPU depending on the
-current usage. To do this the CPU must have the capability to
-switch the frequency very quickly.  There are a number of sysfs file
-accessible parameters:
+The CPUfreq governor "ondemand" sets the CPU depending on the current system
+load. Load estimation is triggered by the scheduler through the
+update_util_data->func hook; when triggered, cpufreq checks the CPU-usage
+statistics over the last period and the governor sets the CPU accordingly.
+The CPU must have the capability to switch the frequency very quickly.
+There are a number of sysfs file accessible parameters:

 sampling_rate: measured in uS (10^-6 seconds), this is how often you
 want the kernel to look at the CPU usage and to make decisions on
@@ -145,7 +141,7 @@ of 'sampling_rate' needs to be for the kernel to make a decision on
 whether it should increase the frequency.  For example when it is set
 to its default value of '95' it means that between the checking
 intervals the CPU needs to be on average more than 95% in use to then
-decide that the CPU frequency needs to be increased.
+decide that the CPU frequency needs to be increased.

 ignore_nice_load: this parameter takes a value of '0' or '1'. When
 set to '0' (its default), all processes are counted towards the
@@ -196,7 +192,7 @@ The CPUfreq governor "conservative", much like the "ondemand"
 governor, sets the CPU depending on the current usage.  It differs in
 behaviour in that it gracefully increases and decreases the CPU speed
 rather than jumping to max speed the moment there is any load on the
-CPU.  This behaviour more suitable in a battery powered environment.
+CPU. This behaviour is more suitable in a battery powered environment.
 The governor is tweaked in the same manner as the "ondemand" governor
 through sysfs with the addition of:

@@ -218,6 +214,21 @@ a decision on when to decrease the frequency while running in any
 speed. Load for frequency increase is still evaluated every
 sampling rate.

+
+2.6 Schedutil
+-------------
+
+The "schedutil" governor aims at a better integration with the CPU scheduler.
+Load estimation is achieved through the scheduler's Per-Entity Load Tracking
+(PELT) mechanism, which also provides information about the recent load [2].
+This governor currently works only for tasks managed by CFS: real-time tasks
+are always run at the maximum OPP.
+Unlike all the other governors, the code is located under the kernel/sched/
+directory.
+
+For an in-depth comparison with the other governors refer to [1].
+
+
 3. The Governor Interface in the CPUfreq Core
 =============================================

@@ -225,26 +236,15 @@ A new governor must register itself with the CPUfreq core using
 "cpufreq_register_governor". The struct cpufreq_governor, which has to
 be passed to that function, must contain the following values:

-governor->name -    A unique name for this governor
-governor->governor -    The governor callback function
-governor->owner -    .THIS_MODULE for the governor module (if
-    appropriate)
-
-The governor->governor callback is called with the current (or to-be-set)
-cpufreq_policy struct for that CPU, and an unsigned int event. The
-following events are currently defined:
-
-CPUFREQ_GOV_START:   This governor shall start its duty for the CPU
-     policy->cpu
-CPUFREQ_GOV_STOP:    This governor shall end its duty for the CPU
-     policy->cpu
-CPUFREQ_GOV_LIMITS:  The limits for CPU policy->cpu have changed to
-     policy->min and policy->max.
+governor->name          A unique name for this governor
+governor->owner         .THIS_MODULE for the governor module (if
+                        appropriate)

-If you need other "events" externally of your driver, _only_ use the
-cpufreq_governor_l(unsigned int cpu, unsigned int event) call to the
-CPUfreq core to ensure proper locking.
+plus a set of hooks to the functions implementing the governor's logic.

+Demand-based Switching (DBS) governors (e.g., ondemand, conservative) wrap
+cpufreq_governor inside the dbs_governor struct, which provides sampling and
+threshold information through the additional dbs_data struct.

 The CPUfreq governor may call the CPU processor driver using one of
 these two functions:
@@ -262,8 +262,15 @@ What's the difference between these two functions? When your governor
 still is in a direct code path of a call to governor->governor, the
 per-CPU cpufreq lock is still held in the cpufreq core, and there's
 no need to lock it again (in fact, this would cause a deadlock). So
-use __cpufreq_driver_target only in these cases. In all other cases
-(for example, when there's a "daemonized" function that wakes up
+use __cpufreq_driver_target only in these cases. In all other cases
+(for example, when there's a "daemonized" function that wakes up
 every second), use cpufreq_driver_target to lock the cpufreq per-CPU
 lock before the command is passed to the cpufreq processor driver.

+
+4. References
+=============
+
+[1] Improvements in CPU frequency management: https://lwn.net/Articles/682391/
+[2] Per-entity load tracking: https://lwn.net/Articles/531853/
+
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 7e05c5e..30feeb3 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -115,7 +115,7 @@ struct cpufreq_policy {
  *   guarantee that frequency can be changed on any CPU sharing the
  *   policy and that the change will affect all of the policy CPUs then.
  * - fast_switch_enabled is to be set by governors that support fast
- *   freqnency switching with the help of cpufreq_enable_fast_switch().
+ *   frequency switching with the help of cpufreq_enable_fast_switch().
  */
  bool fast_switch_possible;
  bool fast_switch_enabled;
-- 
2.7.4

