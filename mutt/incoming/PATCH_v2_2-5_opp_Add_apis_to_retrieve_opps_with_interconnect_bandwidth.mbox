From vireshk  Wed May  4 13:48:11 2022
Delivered-To: viresh.kumar@linaro.org
Received: from pop.gmail.com [142.250.4.108] 	by vireshk-i7 with POP3 (fetchmail-6.4.2) 	for <vireshk@localhost> (single-drop); Wed, 04 May 2022 13:48:11 +0530 (IST)
Received: by 2002:a5e:8b42:0:0:0:0:0 with SMTP id z2csp488946iom;         Wed, 4 May 2022 01:18:01 -0700 (PDT)
X-Google-Smtp-Source: ABdhPJxObTtvPyzV89lWXoZYojbq3tn3axFkxFlToiwxWCAEv7NgGsoZ1S5velQMemM5eCNXgKBX
X-Received: by 2002:a05:6808:1912:b0:326:12f6:7d5a with SMTP id bf18-20020a056808191200b0032612f67d5amr3516899oib.132.1651652281065;         Wed, 04 May 2022 01:18:01 -0700 (PDT)
ARC-Seal: i=1; a=rsa-sha256; t=1651652281; cv=none;         d=google.com; s=arc-20160816;         b=u+6ouPcM/0P6UpAmSjnuDmSIewetaOiJiR0nvVwgvy9IQD45X/eMwF7g5US8kkkQuZ          Ln0vN6RfHcpvCWudUSL0QqY+txQ17kJYWnZJkYbm5jjIdujJSNhQXvFTQDqcZNwrqeP/          w0ldGmmwi8j5P04kZQIuM4eiBRfgh6icogt54bgdwIttLEE9SekmHwa0QWYMcW6Fb+EF          G0neqQzqgx2jJTgd1Fbw57nX+u+JD5j7sBIEAK5CplH/+kSQl4HxT6ZuaPWtMlRwKiQH          uDdrfoEDkab6iCTbOVHB6t/9TDT/nGmYecBBDpFUThgauoqXuGiUASGAb0ryMFxulC2V          xSXw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=arc-20160816;         h=content-transfer-encoding:mime-version:references:in-reply-to          :message-id:date:subject:cc:to:from:dkim-signature:dmarc-filter          :delivered-to;         bh=UkkhaokilCoJ0QaueTDdKBuZpYOWRWhVaZ7JrjJkA3o=;         b=ib20yZWDRiz6Oej+hadI64IFAQCRzbPtU48Lb/k2XYrGvLtOG1sNTdSfcc84l5KKPw          xOlAon6CzQrsebgQNkwAfJnmyOzOS/Naw47B/dVF4BRSNT/WbJBAz5WOYpmknAz99zhU          5ih+BUlZQ9m+bjCOvnqXhIjIUG1Kiyc30rejuPyzrGE6N7abk6WoOSbx5TAt8z/NUvfk          GhiC3ETkq5QZOSpQY3Z0JUVgtPghXDVUg1JL/GQTTwVTWd4G4VImZ3OFMUf4O1D6WUmF          +JIpiOSKJtZMYfAsbmeTsjHKrhcmwn9BrEhgB1hvGFa2EkwTDYJ9E3BDeKFxnnAoOMbZ          1YUQ==
ARC-Authentication-Results: i=1; mx.google.com;        dkim=pass header.i=@linaro.org header.s=google header.b=Y11uNctI;        spf=pass (google.com: domain of srs0=jd6x=vm=linaro.org=krzysztof.kozlowski@kernel.org designates 139.178.84.217 as permitted sender) smtp.mailfrom="SRS0=JD6x=VM=linaro.org=krzysztof.kozlowski@kernel.org";        dmarc=pass (p=NONE sp=NONE dis=NONE) header.from=linaro.org
Return-Path: <SRS0=JD6x=VM=linaro.org=krzysztof.kozlowski@kernel.org>
Received: from dfw.source.kernel.org (dfw.source.kernel.org. [139.178.84.217])         by mx.google.com with ESMTPS id s33-20020a056870612100b000ed0b7fc8basi5360640oae.10.2022.05.04.01.18.00         for <viresh.kumar@linaro.org>         (version=TLS1_2 cipher=ECDHE-ECDSA-AES128-GCM-SHA256 bits=128/128);         Wed, 04 May 2022 01:18:01 -0700 (PDT)
Received-SPF: pass (google.com: domain of srs0=jd6x=vm=linaro.org=krzysztof.kozlowski@kernel.org designates 139.178.84.217 as permitted sender) client-ip=139.178.84.217;
Authentication-Results: mx.google.com;        dkim=pass header.i=@linaro.org header.s=google header.b=Y11uNctI;        spf=pass (google.com: domain of srs0=jd6x=vm=linaro.org=krzysztof.kozlowski@kernel.org designates 139.178.84.217 as permitted sender) smtp.mailfrom="SRS0=JD6x=VM=linaro.org=krzysztof.kozlowski@kernel.org";        dmarc=pass (p=NONE sp=NONE dis=NONE) header.from=linaro.org
Received: from smtp.kernel.org (relay.kernel.org [52.25.139.140]) 	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits)) 	(No client certificate requested) 	by dfw.source.kernel.org (Postfix) with ESMTPS id C5619617CC 	for <viresh.kumar@linaro.org>; Wed,  4 May 2022 08:18:00 +0000 (UTC)
Received: by smtp.kernel.org (Postfix) 	id 9B9E4C385C1; Wed,  4 May 2022 08:18:00 +0000 (UTC)
Delivered-To: vireshk@kernel.org
Received: from mail-ed1-f44.google.com (mail-ed1-f44.google.com [209.85.208.44]) 	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits)) 	(No client certificate requested) 	by smtp.kernel.org (Postfix) with ESMTPS id 6F0B5C385A5 	for <vireshk@kernel.org>; Wed,  4 May 2022 08:17:56 +0000 (UTC)
DMARC-Filter: OpenDMARC Filter v1.4.1 smtp.kernel.org 6F0B5C385A5
Authentication-Results: smtp.kernel.org; dmarc=pass (p=none dis=none) header.from=linaro.org
Authentication-Results: smtp.kernel.org; spf=pass smtp.mailfrom=linaro.org
Received: by mail-ed1-f44.google.com with SMTP id a21so853184edb.1         for <vireshk@kernel.org>; Wed, 04 May 2022 01:17:56 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;         d=linaro.org; s=google;         h=from:to:cc:subject:date:message-id:in-reply-to:references          :mime-version:content-transfer-encoding;         bh=UkkhaokilCoJ0QaueTDdKBuZpYOWRWhVaZ7JrjJkA3o=;         b=Y11uNctIy3cOjG6//dW4N/QbxtkNnNXXbt+YGwGQrk/ajhsEyznptbi8AU2y1d8d3m          xfJFJj/HnqUXGjTRJbdMWvjs35Tjktq5qksuGSqzGMQdf++TkE03pAq06h4VxV9JdBep          vvpF9B6o3zxxstfB5dwrksjHu8wRR+s5jjbMFL2oEE8nv93HeUz8Hhu09yoRtOE16nCr          fFvTMcPo++ZeX16PQDLYmGqbzqeMZ83XFCbugAF0aM+1jBvRF+GbIS8wv8AhoMQdP5Ax          8CytUGSiRWGADXtdvZC/Lw86iFzqKMIdbFBAMCYtpviYOQ1PkX2yyVG/YDTk2vQdx19f          CtBg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;         d=1e100.net; s=20210112;         h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to          :references:mime-version:content-transfer-encoding;         bh=UkkhaokilCoJ0QaueTDdKBuZpYOWRWhVaZ7JrjJkA3o=;         b=CiHh2jaRWHoDo4CG5s74JxLWL1ki2uRFaJKhJ1KdZdwA8UNV7JsPBwBxQKZNHo1cvT          rGdm5vLo16V/+eRW4kBYBu0OZZpHK91rkS/nqjOEZNV9S18F5X1XmrWpyuJME6DvVzni          WoF8cj86bsoxPy+Gp/Uj5wwcAkSyEpI+mnK+Gpb3vTnULBfLrWsBSuRngstrYSkR1WLb          RSH8c72ywmVs4giSxK5JXEgFl7t4+JDLgHOV3YEFbZDf7vWruF4hfTRhRW39q6v8cDVr          8vNoxQ89MTVtOYK6kUfj/XfU8/UvZVLNgVhN6Ug12pPiTISrp7sFBQ9U3pYLF5z0wlyP          +JHg==
X-Gm-Message-State: AOAM532arrc+oRIaHdr5eFeO0HjonNcb8xJSwI6t62vHGZdmEYX8Uj+C 	v2xniLlhsBi7Fb3b+jNhWCysOnhdDYmGmw==
X-Received: by 2002:a05:6402:35c3:b0:423:f765:4523 with SMTP id z3-20020a05640235c300b00423f7654523mr21785036edc.311.1651652274429;         Wed, 04 May 2022 01:17:54 -0700 (PDT)
Received: from localhost.localdomain (xdsl-188-155-176-92.adslplus.ch. [188.155.176.92])         by smtp.gmail.com with ESMTPSA id l21-20020a056402345500b0042617ba6393sm8781322edc.29.2022.05.04.01.17.53         (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);         Wed, 04 May 2022 01:17:53 -0700 (PDT)
From: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
To: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>, 	Andy Gross <agross@kernel.org>, 	Bjorn Andersson <bjorn.andersson@linaro.org>, 	Georgi Djakov <djakov@kernel.org>, 	Rob Herring <robh+dt@kernel.org>, 	Catalin Marinas <catalin.marinas@arm.com>, 	Will Deacon <will@kernel.org>, 	Viresh Kumar <vireshk@kernel.org>, 	Nishanth Menon <nm@ti.com>, 	Stephen Boyd <sboyd@kernel.org>, 	"Rafael J. Wysocki" <rafael@kernel.org>, 	linux-arm-msm@vger.kernel.org, 	linux-pm@vger.kernel.org, 	devicetree@vger.kernel.org, 	linux-kernel@vger.kernel.org, 	linux-arm-kernel@lists.infradead.org
Cc: Thara Gopinath <thara.gopinath@linaro.org>
Subject: [PATCH v2 2/5] opp: Add apis to retrieve opps with interconnect bandwidth
Date: Wed,  4 May 2022 10:17:32 +0200
Message-Id: <20220504081735.26906-3-krzysztof.kozlowski@linaro.org>
X-Mailer: git-send-email 2.32.0
In-Reply-To: <20220504081735.26906-1-krzysztof.kozlowski@linaro.org>
References: <20220504081735.26906-1-krzysztof.kozlowski@linaro.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Length: 5724
Lines: 183

Add dev_pm_opp_find_bw_ceil and dev_pm_opp_find_bw_floor to retrieve opps
based on interconnect associated with the opp and bandwidth. The index
variable is the index of the interconnect as specified in the opp table
in Devicetree.

Co-developed-by: Thara Gopinath <thara.gopinath@linaro.org>
Signed-off-by: Thara Gopinath <thara.gopinath@linaro.org>
Signed-off-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
---
 drivers/opp/core.c     | 120 +++++++++++++++++++++++++++++++++++++++++
 include/linux/pm_opp.h |  19 +++++++
 2 files changed, 139 insertions(+)

diff --git a/drivers/opp/core.c b/drivers/opp/core.c
index 2945f3c1ce09..8125342cee2f 100644
--- a/drivers/opp/core.c
+++ b/drivers/opp/core.c
@@ -729,6 +729,126 @@ struct dev_pm_opp *dev_pm_opp_find_freq_ceil_by_volt(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(dev_pm_opp_find_freq_ceil_by_volt);
 
+/**
+ * dev_pm_opp_find_bw_ceil() - Search for a rounded ceil bandwidth
+ * @dev:	device for which we do this operation
+ * @freq:	start bandwidth
+ * @index:	which bandwidth to compare, in case of OPPs with several values
+ *
+ * Search for the matching floor *available* OPP from a starting bandwidth
+ * for a device.
+ *
+ * Return: matching *opp and refreshes *bw accordingly, else returns
+ * ERR_PTR in case of error and should be handled using IS_ERR. Error return
+ * values can be:
+ * EINVAL:	for bad pointer
+ * ERANGE:	no match found for search
+ * ENODEV:	if device not found in list of registered devices
+ *
+ * The callers are required to call dev_pm_opp_put() for the returned OPP after
+ * use.
+ */
+struct dev_pm_opp *dev_pm_opp_find_bw_ceil(struct device *dev,
+					   unsigned int *bw, int index)
+{
+	struct opp_table *opp_table;
+	struct dev_pm_opp *temp_opp, *opp = ERR_PTR(-ERANGE);
+
+	if (!dev || !bw) {
+		dev_err(dev, "%s: Invalid argument bw=%p\n", __func__, bw);
+		return ERR_PTR(-EINVAL);
+	}
+
+	opp_table = _find_opp_table(dev);
+	if (IS_ERR(opp_table))
+		return ERR_CAST(opp_table);
+
+	if (index >= opp_table->path_count)
+		return ERR_PTR(-EINVAL);
+
+	mutex_lock(&opp_table->lock);
+
+	list_for_each_entry(temp_opp, &opp_table->opp_list, node) {
+		if (temp_opp->available && temp_opp->bandwidth) {
+			if (temp_opp->bandwidth[index].peak >= *bw) {
+				opp = temp_opp;
+				*bw = opp->bandwidth[index].peak;
+
+				/* Increment the reference count of OPP */
+				dev_pm_opp_get(opp);
+				break;
+			}
+		}
+	}
+
+	mutex_unlock(&opp_table->lock);
+	dev_pm_opp_put_opp_table(opp_table);
+
+	return opp;
+}
+EXPORT_SYMBOL_GPL(dev_pm_opp_find_bw_ceil);
+
+/**
+ * dev_pm_opp_find_bw_floor() - Search for a rounded floor bandwidth
+ * @dev:	device for which we do this operation
+ * @freq:	start bandwidth
+ * @index:	which bandwidth to compare, in case of OPPs with several values
+ *
+ * Search for the matching floor *available* OPP from a starting bandwidth
+ * for a device.
+ *
+ * Return: matching *opp and refreshes *bw accordingly, else returns
+ * ERR_PTR in case of error and should be handled using IS_ERR. Error return
+ * values can be:
+ * EINVAL:	for bad pointer
+ * ERANGE:	no match found for search
+ * ENODEV:	if device not found in list of registered devices
+ *
+ * The callers are required to call dev_pm_opp_put() for the returned OPP after
+ * use.
+ */
+struct dev_pm_opp *dev_pm_opp_find_bw_floor(struct device *dev,
+					    unsigned int *bw, int index)
+{
+	struct opp_table *opp_table;
+	struct dev_pm_opp *temp_opp, *opp = ERR_PTR(-ERANGE);
+
+	if (!dev || !bw) {
+		dev_err(dev, "%s: Invalid argument bw=%p\n", __func__, bw);
+		return ERR_PTR(-EINVAL);
+	}
+
+	opp_table = _find_opp_table(dev);
+	if (IS_ERR(opp_table))
+		return ERR_CAST(opp_table);
+
+	if (index >= opp_table->path_count)
+		return ERR_PTR(-EINVAL);
+
+	mutex_lock(&opp_table->lock);
+
+	list_for_each_entry(temp_opp, &opp_table->opp_list, node) {
+		if (temp_opp->available && temp_opp->bandwidth) {
+			/* go to the next node, before choosing prev */
+			if (temp_opp->bandwidth[index].peak > *bw)
+				break;
+			opp = temp_opp;
+		}
+	}
+
+	/* Increment the reference count of OPP */
+	if (!IS_ERR(opp))
+		dev_pm_opp_get(opp);
+	mutex_unlock(&opp_table->lock);
+	dev_pm_opp_put_opp_table(opp_table);
+
+	if (!IS_ERR(opp))
+		*bw = opp->bandwidth[index].peak;
+
+	return opp;
+}
+EXPORT_SYMBOL_GPL(dev_pm_opp_find_bw_floor);
+
 static int _set_opp_voltage(struct device *dev, struct regulator *reg,
 			    struct dev_pm_opp_supply *supply)
 {
diff --git a/include/linux/pm_opp.h b/include/linux/pm_opp.h
index 0d85a63a1f78..dcea178868c9 100644
--- a/include/linux/pm_opp.h
+++ b/include/linux/pm_opp.h
@@ -129,6 +129,13 @@ struct dev_pm_opp *dev_pm_opp_find_freq_ceil_by_volt(struct device *dev,
 
 struct dev_pm_opp *dev_pm_opp_find_freq_ceil(struct device *dev,
 					     unsigned long *freq);
+
+struct dev_pm_opp *dev_pm_opp_find_bw_ceil(struct device *dev,
+					   unsigned int *bw, int index);
+
+struct dev_pm_opp *dev_pm_opp_find_bw_floor(struct device *dev,
+					   unsigned int *bw, int index);
+
 void dev_pm_opp_put(struct dev_pm_opp *opp);
 
 int dev_pm_opp_add(struct device *dev, unsigned long freq,
@@ -279,6 +286,18 @@ static inline struct dev_pm_opp *dev_pm_opp_find_freq_ceil(struct device *dev,
 	return ERR_PTR(-EOPNOTSUPP);
 }
 
+static inline struct dev_pm_opp *dev_pm_opp_find_bw_ceil(struct device *dev,
+					unsigned int *bw, int index)
+{
+	return ERR_PTR(-EOPNOTSUPP);
+}
+
+static inline struct dev_pm_opp *dev_pm_opp_find_bw_floor(struct device *dev,
+					unsigned int *bw, int index)
+{
+	return ERR_PTR(-EOPNOTSUPP);
+}
+
 static inline void dev_pm_opp_put(struct dev_pm_opp *opp) {}
 
 static inline int dev_pm_opp_add(struct device *dev, unsigned long freq,
-- 
2.32.0

