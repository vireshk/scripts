From vireshk  Thu Jul 27 15:32:51 2017
Delivered-To: viresh.kumar@linaro.org
Received: from gmail-pop.l.google.com [74.125.68.109] 	by vireshk-i7 with POP3 (fetchmail-6.3.26) 	for <vireshk@localhost> (single-drop); Thu, 27 Jul 2017 15:32:51 +0530 (IST)
Received: by 10.74.11.193 with SMTP id 62csp1729713oou;         Thu, 27 Jul 2017 03:01:51 -0700 (PDT)
X-Received: by 10.202.172.11 with SMTP id v11mr3228620oie.164.1501149711149;         Thu, 27 Jul 2017 03:01:51 -0700 (PDT)
ARC-Seal: i=1; a=rsa-sha256; t=1501149711; cv=none;         d=google.com; s=arc-20160816;         b=WToD139kj8qXQBOnbBXhtcOBwI8+VSYa7Rf/+//x837tU0rNXPBVXIZBau48otgdVK          PLXUaUVbixtdjL2cVs74Yw/BBKfLdXSYwFiZQvqWPhaXVASD0CEnlnVvSowjIsZ4KYFj          nEJ944bA3bAT/xbXxiXyOxnooxIAMqW1fbW8HFNM7t0nXXqzubsDcdihmJv6rpg3fZee          NYSxPjIoKNuk826RMMwYtlfPCsg5ZG0r7C1HpH15opYud5PZsa8dvuimZWHSZt4mvvoz          wgxIjClLieFxaNNkFPGzslafnSUZ24Z/ybjw0IAD3SxHflCsKlBUTAjr8VE4/tBjktlt          t2qw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=arc-20160816;         h=message-id:date:subject:cc:to:from:dmarc-filter:delivered-to          :arc-authentication-results;         bh=uI7Uv5RAVutigaEv0HqUi/Ko9gzphcVt5kcUZqq4Jag=;         b=xJHemhmqoiuJiaHbs/ieRoa0ndv+0FU7I2HaMmrQF72T/8DChIA5DZXn/5LhdIOdnq          JFxHsDFZKuIAjdGram3TF4khB1EMW5E1XhjHo2uOVlnZwtqpTXcJZ+eG9dgp02cz+XHT          oOgJEKbzLXSQLwENE8FNZ+629IaBDI85diUVNYIbOrcEts3fFWctV4AN7J+5JmrL9LsR          w7aJW7rnC1HTF/Md0XQ0UIhLc1t25gSX1VZWONAYD1TuIOsOWNh+QPRb0+lyd/qGGpWM          VMJfRP871pQeR1L0cQ2IEM61T0Yj985Pry/8ziPnyN+Ung9xQD/r/Nt2ptd19p6Ivq5g          oGDw==
ARC-Authentication-Results: i=1; mx.google.com;        spf=pass (google.com: best guess record for domain of srs0=r4ka=66=intel.com=waldemarx.rymarkiewicz@kernel.org designates 198.145.29.99 as permitted sender) smtp.mailfrom=SRS0=R4KA=66=intel.com=waldemarx.rymarkiewicz@kernel.org
Return-Path: <SRS0=R4KA=66=intel.com=waldemarx.rymarkiewicz@kernel.org>
Received: from mail.kernel.org (mail.kernel.org. [198.145.29.99])         by mx.google.com with ESMTPS id s132si10173686oig.299.2017.07.27.03.01.51         for <viresh.kumar@linaro.org>         (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);         Thu, 27 Jul 2017 03:01:51 -0700 (PDT)
Received-SPF: pass (google.com: best guess record for domain of srs0=r4ka=66=intel.com=waldemarx.rymarkiewicz@kernel.org designates 198.145.29.99 as permitted sender) client-ip=198.145.29.99;
Authentication-Results: mx.google.com;        spf=pass (google.com: best guess record for domain of srs0=r4ka=66=intel.com=waldemarx.rymarkiewicz@kernel.org designates 198.145.29.99 as permitted sender) smtp.mailfrom=SRS0=R4KA=66=intel.com=waldemarx.rymarkiewicz@kernel.org
Received: by mail.kernel.org (Postfix) 	id 8719122BD1; Thu, 27 Jul 2017 10:01:50 +0000 (UTC)
Delivered-To: vireshk@kernel.org
Received: from mga07.intel.com (mga07.intel.com [134.134.136.100]) 	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits)) 	(No client certificate requested) 	by mail.kernel.org (Postfix) with ESMTPS id 6AD6C22B5D 	for <vireshk@kernel.org>; Thu, 27 Jul 2017 10:01:50 +0000 (UTC)
DMARC-Filter: OpenDMARC Filter v1.3.2 mail.kernel.org 6AD6C22B5D
Authentication-Results: mail.kernel.org; dmarc=none (p=none dis=none) header.from=intel.com
Authentication-Results: mail.kernel.org; spf=pass smtp.mailfrom=waldemarx.rymarkiewicz@intel.com
Received: from fmsmga006.fm.intel.com ([10.253.24.20])   by orsmga105.jf.intel.com with ESMTP; 27 Jul 2017 03:01:35 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="5.40,419,1496127600";     d="scan'208";a="132593128"
Received: from unknown (HELO mucrsa0015.muc.lantiq.com) ([10.62.163.98])   by fmsmga006.fm.intel.com with ESMTP; 27 Jul 2017 03:01:33 -0700
From: Waldemar Rymarkiewicz <waldemarx.rymarkiewicz@intel.com>
To: linux-pm@vger.kernel.org
Cc: waldemar.rymarkiewicz@gmail.com, 	Waldemar Rymarkiewicz <waldemarx.rymarkiewicz@intel.com>, 	Viresh Kumar <vireshk@kernel.org>, 	Nishanth Menon <nm@ti.com>, 	Stephen Boyd <sboyd@codeaurora.org>, 	"Rafael J. Wysocki" <rjw@rjwysocki.net>
Subject: [PATCH v5 1/1] PM / OPP: Fix get sharing cpus when hotplug is used
Date: Thu, 27 Jul 2017 12:01:17 +0200
Message-Id: <20170727100128.26818-1-waldemarx.rymarkiewicz@intel.com>
X-Mailer: git-send-email 2.10.1
Status: RO
Content-Length: 3212
Lines: 90

We fail dev_pm_opp_of_get_sharing_cpus() when possible cpu device does not
exist. This can happen on platforms where not all possible CPUs are
available at start up ie. hotplugged out. Cpu device is not registered in
the system so we are not able to check struct device to set the sharing
CPUs bitmask properly.

Example (real use case):
2 physical MIPS cores, 4 VPE, cpu0/2 run Linux and cpu1/3 are not available
for Linux at boot up. cpufreq-dt driver + opp v2 fail to register opp_table
due to the fact there is no struct device for cpu1 (remains offline at
bootup).

To solve the bug, stop using device struct to check device_node. Instead
get cpu device_node directly from device tree with of_get_cpu_node().

Signed-off-by: Waldemar Rymarkiewicz <waldemarx.rymarkiewicz@intel.com>
Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
---
 drivers/base/power/opp/of.c | 29 +++++++++++++++++------------
 1 file changed, 17 insertions(+), 12 deletions(-)

diff --git a/drivers/base/power/opp/of.c b/drivers/base/power/opp/of.c
index 57eec1c..fba6d2e 100644
--- a/drivers/base/power/opp/of.c
+++ b/drivers/base/power/opp/of.c
@@ -248,15 +248,22 @@ void dev_pm_opp_of_remove_table(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(dev_pm_opp_of_remove_table);
 
-/* Returns opp descriptor node for a device, caller must do of_node_put() */
-struct device_node *dev_pm_opp_of_get_opp_desc_node(struct device *dev)
+/* Returns opp descriptor node for a device node, caller must
+ * do of_node_put() */
+static struct device_node *_opp_of_get_opp_desc_node(struct device_node *np)
 {
 	/*
 	 * There should be only ONE phandle present in "operating-points-v2"
 	 * property.
 	 */
 
-	return of_parse_phandle(dev->of_node, "operating-points-v2", 0);
+	return of_parse_phandle(np, "operating-points-v2", 0);
+}
+
+/* Returns opp descriptor node for a device, caller must do of_node_put() */
+struct device_node *dev_pm_opp_of_get_opp_desc_node(struct device *dev)
+{
+	return _opp_of_get_opp_desc_node(dev->of_node);
 }
 EXPORT_SYMBOL_GPL(dev_pm_opp_of_get_opp_desc_node);
 
@@ -572,8 +579,7 @@ EXPORT_SYMBOL_GPL(dev_pm_opp_of_cpumask_add_table);
 int dev_pm_opp_of_get_sharing_cpus(struct device *cpu_dev,
 				   struct cpumask *cpumask)
 {
-	struct device_node *np, *tmp_np;
-	struct device *tcpu_dev;
+	struct device_node *np, *tmp_np, *cpu_np;
 	int cpu, ret = 0;
 
 	/* Get OPP descriptor node */
@@ -593,19 +599,18 @@ int dev_pm_opp_of_get_sharing_cpus(struct device *cpu_dev,
 		if (cpu == cpu_dev->id)
 			continue;
 
-		tcpu_dev = get_cpu_device(cpu);
-		if (!tcpu_dev) {
-			dev_err(cpu_dev, "%s: failed to get cpu%d device\n",
+		cpu_np = of_get_cpu_node(cpu, NULL);
+		if (!cpu_np) {
+			dev_err(cpu_dev, "%s: failed to get cpu%d node\n",
 				__func__, cpu);
-			ret = -ENODEV;
+			ret = -ENOENT;
 			goto put_cpu_node;
 		}
 
 		/* Get OPP descriptor node */
-		tmp_np = dev_pm_opp_of_get_opp_desc_node(tcpu_dev);
+		tmp_np = _opp_of_get_opp_desc_node(cpu_np);
 		if (!tmp_np) {
-			dev_err(tcpu_dev, "%s: Couldn't find opp node.\n",
-				__func__);
+			pr_err("%pOF: Couldn't find opp node\n", cpu_np);
 			ret = -ENOENT;
 			goto put_cpu_node;
 		}
-- 
2.10.1

