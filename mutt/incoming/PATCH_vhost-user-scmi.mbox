From vireshk  Tue Apr  6 16:57:48 2021
Delivered-To: viresh.kumar@linaro.org
Received: from pop.gmail.com [172.217.194.108] 	by vireshk-i7 with POP3 (fetchmail-6.3.26) 	for <vireshk@localhost> (single-drop); Tue, 06 Apr 2021 16:57:48 +0530 (IST)
Received: by 2002:a5e:c00d:0:0:0:0:0 with SMTP id u13csp4395926iol;         Tue, 6 Apr 2021 04:27:10 -0700 (PDT)
X-Received: by 2002:a5d:45c4:: with SMTP id b4mr1748582wrs.277.1617708429922;         Tue, 06 Apr 2021 04:27:09 -0700 (PDT)
ARC-Seal: i=1; a=rsa-sha256; t=1617708429; cv=none;         d=google.com; s=arc-20160816;         b=haCutX0o11pIg2iwEP23oMdc5i4I26LvSlytm3EKb8GIbq6QJ/Keb6gudcDby4vTnq          RnTdrd+sBC7CfcYlUVhjU9acO5XU7IkbyNHPVBrPuEAmBhRxAXX2c9n1c6cdtRPYH/Zy          T2alhUiCBCOeKgpw6Efq1dYpl7GJKxoBBF12i2NPaPi2AEl/6pKbZE7Jy3IytgfxZKYk          zJEqx3Y/y5KK7URZ17s31VCdVNHvu9Kq6oL8Vz0s3/xo9NZYTlBYCYtgzjD7E8e1D385          qF4+Rq3gTwoVUBmBrgn/+0vFUPR+8dhKsBAeTIHiUjl4I0NMPXxZpD2dpuVnesN2jtVi          LmfA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=arc-20160816;         h=message-id:date:subject:cc:to:from:dkim-signature;         bh=I68TQNpkfpWhF3tAwSiBX8G3Mq1N/WCn/UMbTEPm4gE=;         b=qiKtW0C0zUmZzr6YapezhFGsMi552a8c+PB+1GOkskR8hgz90DoTZdY4yhzdMZrN4h          LwXPteKzHWfU0fpUgbLiXiS8pEdb/15UVOAQBQwCtAFgUxILBXGoQeUl+gIGspSQEo7U          90w3B1cspI2msC0rV35sHLLuZ2KPnf9lc7ZTjm7VWikqDVIu8LrKoUSMEkhWiNj43lUP          RekKsAjdqIpYSJZwmi6mPko4guPJoQnshR90q5mvS5LqSeAz3IzVL84goH+fYnYf/5Fx          XXfJQC/tuaO/40Auv2TlrYKMmLzGk9wb9wl59Iywu0UOz9C8rXPp2XKTPJ7yccNq1Hzw          laYQ==
ARC-Authentication-Results: i=1; mx.google.com;        dkim=pass header.i=@linaro.org header.s=google header.b=DnbtIvAu;        spf=pass (google.com: domain of vincent.guittot@linaro.org designates 209.85.220.41 as permitted sender) smtp.mailfrom=vincent.guittot@linaro.org;        dmarc=pass (p=NONE sp=NONE dis=NONE) header.from=linaro.org
Return-Path: <vincent.guittot@linaro.org>
Received: from mail-sor-f41.google.com (mail-sor-f41.google.com. [209.85.220.41])         by mx.google.com with SMTPS id b8sor1131995wmj.26.2021.04.06.04.27.09         for <viresh.kumar@linaro.org>         (Google Transport Security);         Tue, 06 Apr 2021 04:27:09 -0700 (PDT)
Received-SPF: pass (google.com: domain of vincent.guittot@linaro.org designates 209.85.220.41 as permitted sender) client-ip=209.85.220.41;
Authentication-Results: mx.google.com;        dkim=pass header.i=@linaro.org header.s=google header.b=DnbtIvAu;        spf=pass (google.com: domain of vincent.guittot@linaro.org designates 209.85.220.41 as permitted sender) smtp.mailfrom=vincent.guittot@linaro.org;        dmarc=pass (p=NONE sp=NONE dis=NONE) header.from=linaro.org
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;         d=linaro.org; s=google;         h=from:to:cc:subject:date:message-id;         bh=I68TQNpkfpWhF3tAwSiBX8G3Mq1N/WCn/UMbTEPm4gE=;         b=DnbtIvAuM7PFyeh37PsNSV2hMSQRLzAELJmfB0pN1GC2qI/yNbkfNOvy94zlu15VfY          QG2hWz7QgAH8o0MFLPFAFMTH8HsdciA0EjOYRo0e4oaqKgkTBDpqQjRWv3NAxYRhCvj5          R5rvr/3jn4dWQbwGkd5Qcs7GXYciBFhqcqM9WXCtP54hMuErsV415ATX8d80pvI6geUs          BUEBNXAwbCdR9lzgpGT5YvWK8Wb7PT2pjyCEP6HC7i+viJ+M1S/ZMp22YnMRm38qDT3u          cbYjtp3xiDnLIuEHCWzb4gE63/ghENb3a9XCVj6Gi+Ya0y5gj3HtiAQVab8liIM6frET          j9EA==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;         d=1e100.net; s=20161025;         h=x-gm-message-state:from:to:cc:subject:date:message-id;         bh=I68TQNpkfpWhF3tAwSiBX8G3Mq1N/WCn/UMbTEPm4gE=;         b=JK6FwFEkPW5VzyUIVJwm1ePPW9/1d35p/zEPJE3XlrQ5TaRd5/1K2zZumGdwgynU4m          XT8nwQyaS6waaMONmzCKlGOWQKovTauTRDpGPVRbMPuJOreZQAOOZugfWQMD+Ed6ZEK9          3URdId13mRBpCw7gkMqPCeMMVT5yNDuhFhxLLXIzRup3Te8TewnoU4d/lfuDbkx+VFK9          r2/ZYreNpyIpEzCDO1a1knNFpkZZhdo5RMKRTCtOdzPQBkP4GmMBYE3uVuDXj68BXEz2          wZH5ec0fPeUIN0hm4wyU/NpNPNFyzIjOEq+Gosv77rcpDpgyUzonzTiqkTPkb5eo7LRV          dHVQ==
X-Gm-Message-State: AOAM530bZxnpdKAGg2S5HQSHVFoOLV/0rnmrOQeDxn6uXmItm8v68BQf 	PlVsZZFXvofJqmtne2otSoZ6UxeHs7ifmXeA
X-Google-Smtp-Source: ABdhPJzsoIuy6CsFUtZFsBLPcBjvIXvgIWJT2LdU2uLb0Ct968hVmQiA9u6JBMdzJWixkCHc9sVprA==
X-Received: by 2002:a7b:c357:: with SMTP id l23mr3666472wmj.152.1617708428555;         Tue, 06 Apr 2021 04:27:08 -0700 (PDT)
Return-Path: <vincent.guittot@linaro.org>
Received: from localhost.localdomain ([2a01:e0a:f:6020:29e3:20d8:c45a:54b2])         by smtp.gmail.com with ESMTPSA id b5sm336086wri.57.2021.04.06.04.27.07         (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);         Tue, 06 Apr 2021 04:27:07 -0700 (PDT)
From: Vincent Guittot <vincent.guittot@linaro.org>
To: viresh.kumar@linaro.org
Cc: Vincent Guittot <vincent.guittot@linaro.org>
Subject: [PATCH] vhost-user-scmi
Date: Tue,  6 Apr 2021 13:27:04 +0200
Message-Id: <20210406112704.30587-1-vincent.guittot@linaro.org>
X-Mailer: git-send-email 2.17.1

Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>

# Conflicts:
#	include/standard-headers/linux/virtio_ids.h
---
 hw/virtio/Kconfig                           |   5 +
 hw/virtio/meson.build                       |   2 +
 hw/virtio/vhost-user-scmi-pci.c             |  81 +++++
 hw/virtio/vhost-user-scmi.c                 | 298 ++++++++++++++++
 include/hw/virtio/vhost-user-scmi.h         |  37 ++
 include/standard-headers/linux/virtio_ids.h |   1 +
 tools/meson.build                           |   8 +
 tools/vhost-user-scmi/50-qemu-scmi.json.in  |   5 +
 tools/vhost-user-scmi/main.c                | 356 ++++++++++++++++++++
 tools/vhost-user-scmi/meson.build           |  10 +
 10 files changed, 803 insertions(+)
 create mode 100644 hw/virtio/vhost-user-scmi-pci.c
 create mode 100644 hw/virtio/vhost-user-scmi.c
 create mode 100644 include/hw/virtio/vhost-user-scmi.h
 create mode 100644 tools/vhost-user-scmi/50-qemu-scmi.json.in
 create mode 100644 tools/vhost-user-scmi/main.c
 create mode 100644 tools/vhost-user-scmi/meson.build

diff --git a/hw/virtio/Kconfig b/hw/virtio/Kconfig
index 35ab45e2095c..03da24487d57 100644
--- a/hw/virtio/Kconfig
+++ b/hw/virtio/Kconfig
@@ -63,3 +63,8 @@ config VHOST_USER_I2C
     bool
     default y
     depends on VIRTIO && VHOST_USER
+
+config VHOST_USER_SCMI
+    bool
+    default y
+    depends on VIRTIO && VHOST_USER
diff --git a/hw/virtio/meson.build b/hw/virtio/meson.build
index bc352a600911..8d295700d723 100644
--- a/hw/virtio/meson.build
+++ b/hw/virtio/meson.build
@@ -27,6 +27,8 @@ virtio_ss.add(when: 'CONFIG_VIRTIO_IOMMU', if_true: files('virtio-iommu.c'))
 virtio_ss.add(when: 'CONFIG_VIRTIO_MEM', if_true: files('virtio-mem.c'))
 virtio_ss.add(when: 'CONFIG_VHOST_USER_I2C', if_true: files('vhost-user-i2c.c'))
 virtio_ss.add(when: ['CONFIG_VIRTIO_PCI', 'CONFIG_VHOST_USER_I2C'], if_true: files('vhost-user-i2c-pci.c'))
+virtio_ss.add(when: 'CONFIG_VHOST_USER_SCMI', if_true: files('vhost-user-scmi.c'))
+virtio_ss.add(when: ['CONFIG_VIRTIO_PCI', 'CONFIG_VHOST_USER_SCMI'], if_true: files('vhost-user-scmi-pci.c'))
 
 virtio_pci_ss = ss.source_set()
 virtio_pci_ss.add(when: 'CONFIG_VHOST_VSOCK', if_true: files('vhost-vsock-pci.c'))
diff --git a/hw/virtio/vhost-user-scmi-pci.c b/hw/virtio/vhost-user-scmi-pci.c
new file mode 100644
index 000000000000..a8354ed52d15
--- /dev/null
+++ b/hw/virtio/vhost-user-scmi-pci.c
@@ -0,0 +1,81 @@
+/*
+ * Vhost-user scmi virtio device PCI glue
+ *
+ * Copyright (c) 2021 Viresh Kumar <viresh.kumar@linaro.org>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "qemu/osdep.h"
+#include "hw/qdev-properties.h"
+#include "hw/virtio/vhost-user-scmi.h"
+#include "virtio-pci.h"
+
+struct VHostUserSCMIPCI {
+    VirtIOPCIProxy parent_obj;
+    VHostUserSCMI vdev;
+};
+
+typedef struct VHostUserSCMIPCI VHostUserSCMIPCI;
+
+#define TYPE_VHOST_USER_SCMI_PCI "vhost-user-scmi-pci-base"
+
+DECLARE_INSTANCE_CHECKER(VHostUserSCMIPCI, VHOST_USER_SCMI_PCI,
+                         TYPE_VHOST_USER_SCMI_PCI)
+
+static Property vhost_user_scmi_pci_properties[] = {
+    DEFINE_PROP_UINT32("vectors", VirtIOPCIProxy, nvectors,
+                       DEV_NVECTORS_UNSPECIFIED),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void vhost_user_scmi_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
+{
+    VHostUserSCMIPCI *dev = VHOST_USER_SCMI_PCI(vpci_dev);
+    DeviceState *vdev = DEVICE(&dev->vdev);
+
+    if (vpci_dev->nvectors == DEV_NVECTORS_UNSPECIFIED) {
+        vpci_dev->nvectors = 2;
+    }
+    /* unlike vhost-vsock, we do not need to care about pre-5.1 compat */
+//    virtio_pci_force_virtio_1(vpci_dev);
+
+    qdev_realize(vdev, BUS(&vpci_dev->bus), errp);
+}
+
+static void vhost_user_scmi_pci_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtioPCIClass *k = VIRTIO_PCI_CLASS(klass);
+    PCIDeviceClass *pcidev_k = PCI_DEVICE_CLASS(klass);
+    k->realize = vhost_user_scmi_pci_realize;
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+    device_class_set_props(dc, vhost_user_scmi_pci_properties);
+    pcidev_k->vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;
+    pcidev_k->device_id = 0; /* Set by virtio-pci based on virtio id */
+    pcidev_k->revision = 0x00;
+    pcidev_k->class_id = PCI_CLASS_COMMUNICATION_OTHER;
+}
+
+static void vhost_user_scmi_pci_instance_init(Object *obj)
+{
+    VHostUserSCMIPCI *dev = VHOST_USER_SCMI_PCI(obj);
+
+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                TYPE_VHOST_USER_SCMI);
+}
+
+static const VirtioPCIDeviceTypeInfo vhost_user_scmi_pci_info = {
+    .base_name = TYPE_VHOST_USER_SCMI_PCI,
+    .non_transitional_name = "vhost-user-scmi-pci",
+    .instance_size = sizeof(VHostUserSCMIPCI),
+    .instance_init = vhost_user_scmi_pci_instance_init,
+    .class_init = vhost_user_scmi_pci_class_init,
+};
+
+static void vhost_user_scmi_pci_register(void)
+{
+    virtio_pci_types_register(&vhost_user_scmi_pci_info);
+}
+
+type_init(vhost_user_scmi_pci_register);
diff --git a/hw/virtio/vhost-user-scmi.c b/hw/virtio/vhost-user-scmi.c
new file mode 100644
index 000000000000..da6313e75357
--- /dev/null
+++ b/hw/virtio/vhost-user-scmi.c
@@ -0,0 +1,298 @@
+/*
+ * Vhost-user scmi virtio device
+ *
+ * Copyright (c) 2021 Viresh Kumar <viresh.kumar@linaro.org>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "hw/qdev-properties.h"
+#include "hw/virtio/virtio-bus.h"
+#include "hw/virtio/vhost-user-scmi.h"
+#include "qemu/error-report.h"
+#include "standard-headers/linux/virtio_ids.h"
+
+static void vu_scmi_start(VirtIODevice *vdev)
+{
+    VHostUserSCMI *scmi = VHOST_USER_SCMI(vdev);
+    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));
+    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
+    int ret;
+    int i;
+
+    info_report("vu_scmi_start");
+    if (!k->set_guest_notifiers) {
+        error_report("binding does not support guest notifiers");
+        return;
+    }
+
+    ret = vhost_dev_enable_notifiers(&scmi->vhost_dev, vdev);
+    if (ret < 0) {
+        error_report("Error enabling host notifiers: %d", -ret);
+        return;
+    }
+
+    ret = k->set_guest_notifiers(qbus->parent, scmi->vhost_dev.nvqs, true);
+    if (ret < 0) {
+        error_report("Error binding guest notifier: %d", -ret);
+        goto err_host_notifiers;
+    }
+
+    scmi->vhost_dev.acked_features = vdev->guest_features;
+    ret = vhost_dev_start(&scmi->vhost_dev, vdev);
+    if (ret < 0) {
+        error_report("Error starting vhost-user-scmi: %d", -ret);
+        goto err_guest_notifiers;
+    }
+
+    /*
+     * guest_notifier_mask/pending not used yet, so just unmask
+     * everything here. virtio-pci will do the right thing by
+     * enabling/disabling irqfd.
+     */
+    for (i = 0; i < scmi->vhost_dev.nvqs; i++) {
+        vhost_virtqueue_mask(&scmi->vhost_dev, vdev, i, false);
+    }
+
+    return;
+
+err_guest_notifiers:
+    k->set_guest_notifiers(qbus->parent, scmi->vhost_dev.nvqs, false);
+err_host_notifiers:
+    vhost_dev_disable_notifiers(&scmi->vhost_dev, vdev);
+}
+
+static void vu_scmi_stop(VirtIODevice *vdev)
+{
+    VHostUserSCMI *scmi = VHOST_USER_SCMI(vdev);
+    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));
+    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
+    int ret;
+    info_report("vu_scmi_stop");
+
+    if (!k->set_guest_notifiers) {
+        return;
+    }
+
+    vhost_dev_stop(&scmi->vhost_dev, vdev);
+
+    ret = k->set_guest_notifiers(qbus->parent, scmi->vhost_dev.nvqs, false);
+    if (ret < 0) {
+        error_report("vhost guest notifier cleanup failed: %d", ret);
+        return;
+    }
+
+    vhost_dev_disable_notifiers(&scmi->vhost_dev, vdev);
+}
+
+static void vu_scmi_set_status(VirtIODevice *vdev, uint8_t status)
+{
+    VHostUserSCMI *scmi = VHOST_USER_SCMI(vdev);
+    bool should_start = status & VIRTIO_CONFIG_S_DRIVER_OK;
+
+    info_report("vu_scmi_set_status %d", status);
+    if (!vdev->vm_running) {
+        should_start = false;
+    }
+
+    if (scmi->vhost_dev.started == should_start) {
+        return;
+    }
+
+    if (should_start) {
+        vu_scmi_start(vdev);
+    } else {
+        vu_scmi_stop(vdev);
+    }
+}
+
+static uint64_t vu_scmi_get_features(VirtIODevice *vdev,
+                                    uint64_t requested_features, Error **errp)
+{
+    info_report("vu_scmi_get_features %ld", requested_features);
+    /* No feature bits used yet */
+    return requested_features;
+}
+
+static void vu_scmi_handle_output(VirtIODevice *vdev, VirtQueue *vq)
+{
+    info_report("vu_scmi_handle_output");
+    /*
+     * Not normally called; it's the daemon that handles the queue;
+     * however virtio's cleanup path can call this.
+     */
+}
+
+static void vu_scmi_guest_notifier_mask(VirtIODevice *vdev, int idx, bool mask)
+{
+    VHostUserSCMI *scmi = VHOST_USER_SCMI(vdev);
+
+    vhost_virtqueue_mask(&scmi->vhost_dev, vdev, idx, mask);
+}
+
+static bool vu_scmi_guest_notifier_pending(VirtIODevice *vdev, int idx)
+{
+    VHostUserSCMI *scmi = VHOST_USER_SCMI(vdev);
+    info_report("vu_scmi_guest_notifier_pending %d", idx);
+
+    return vhost_virtqueue_pending(&scmi->vhost_dev, idx);
+}
+
+static void do_vhost_user_cleanup(VirtIODevice *vdev, VHostUserSCMI *scmi)
+{
+    info_report("do_vhost_user_cleanup");
+    vhost_user_cleanup(&scmi->vhost_user);
+    virtio_delete_queue(scmi->req_vq);
+    virtio_cleanup(vdev);
+    g_free(scmi->vhost_dev.vqs);
+    scmi->vhost_dev.vqs = NULL;
+}
+
+static int vu_scmi_connect(DeviceState *dev)
+{
+    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
+    VHostUserSCMI *scmi = VHOST_USER_SCMI(vdev);
+    info_report("vu_scmi_connect");
+
+    if (scmi->connected) {
+        return 0;
+    }
+    scmi->connected = true;
+
+    /* restore vhost state */
+    if (virtio_device_started(vdev, vdev->status)) {
+        vu_scmi_start(vdev);
+    }
+
+    return 0;
+}
+
+static void vu_scmi_disconnect(DeviceState *dev)
+{
+    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
+    VHostUserSCMI *scmi = VHOST_USER_SCMI(vdev);
+
+    info_report("vu_scmi_disconnect");
+    if (!scmi->connected) {
+        return;
+    }
+    scmi->connected = false;
+
+    if (scmi->vhost_dev.started) {
+        vu_scmi_stop(vdev);
+    }
+}
+
+static void vu_scmi_event(void *opaque, QEMUChrEvent event)
+{
+    DeviceState *dev = opaque;
+    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
+    VHostUserSCMI *scmi = VHOST_USER_SCMI(vdev);
+
+    info_report("vu_scmi_event %d", event);
+    switch (event) {
+    case CHR_EVENT_OPENED:
+        if (vu_scmi_connect(dev) < 0) {
+            qemu_chr_fe_disconnect(&scmi->conf.chardev);
+            return;
+        }
+        break;
+    case CHR_EVENT_CLOSED:
+        vu_scmi_disconnect(dev);
+        break;
+    case CHR_EVENT_BREAK:
+    case CHR_EVENT_MUX_IN:
+    case CHR_EVENT_MUX_OUT:
+        /* Ignore */
+        break;
+    }
+}
+
+static void vu_scmi_device_realize(DeviceState *dev, Error **errp)
+{
+    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
+    VHostUserSCMI *scmi = VHOST_USER_SCMI(dev);
+    int ret;
+
+    info_report("vu_scmi_device_realize");
+    if (!scmi->conf.chardev.chr) {
+        error_setg(errp, "missing chardev");
+        return;
+    }
+
+    if (!vhost_user_init(&scmi->vhost_user, &scmi->conf.chardev, errp)) {
+        return;
+    }
+
+    virtio_init(vdev, "vhost-user-scmi", VIRTIO_ID_SCMI, 0);
+
+    scmi->req_vq = virtio_add_queue(vdev, 4, vu_scmi_handle_output);
+    scmi->vhost_dev.nvqs = 1;
+    scmi->vhost_dev.vqs = g_new0(struct vhost_virtqueue, scmi->vhost_dev.nvqs);
+    ret = vhost_dev_init(&scmi->vhost_dev, &scmi->vhost_user,
+                         VHOST_BACKEND_TYPE_USER, 0);
+    if (ret < 0) {
+        error_setg_errno(errp, -ret, "vhost_dev_init() failed");
+        do_vhost_user_cleanup(vdev, scmi);
+    }
+
+    qemu_chr_fe_set_handlers(&scmi->conf.chardev, NULL, NULL, vu_scmi_event, NULL,
+                             dev, NULL, true);
+}
+
+static void vu_scmi_device_unrealize(DeviceState *dev)
+{
+    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
+    VHostUserSCMI *scmi = VHOST_USER_SCMI(dev);
+
+    info_report("vu_scmi_device_realize");
+
+    /* This will stop vhost backend if appropriate. */
+    vu_scmi_set_status(vdev, 0);
+
+    vhost_dev_cleanup(&scmi->vhost_dev);
+
+    do_vhost_user_cleanup(vdev, scmi);
+}
+
+static const VMStateDescription vu_scmi_vmstate = {
+    .name = "vhost-user-scmi",
+    .unmigratable = 1,
+};
+
+static Property vu_scmi_properties[] = {
+    DEFINE_PROP_CHR("chardev", VHostUserSCMI, conf.chardev),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void vu_scmi_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
+
+    device_class_set_props(dc, vu_scmi_properties);
+    dc->vmsd = &vu_scmi_vmstate;
+    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
+    vdc->realize = vu_scmi_device_realize;
+    vdc->unrealize = vu_scmi_device_unrealize;
+    vdc->get_features = vu_scmi_get_features;
+    vdc->set_status = vu_scmi_set_status;
+    vdc->guest_notifier_mask = vu_scmi_guest_notifier_mask;
+    vdc->guest_notifier_pending = vu_scmi_guest_notifier_pending;
+}
+
+static const TypeInfo vu_scmi_info = {
+    .name = TYPE_VHOST_USER_SCMI,
+    .parent = TYPE_VIRTIO_DEVICE,
+    .instance_size = sizeof(VHostUserSCMI),
+    .class_init = vu_scmi_class_init,
+};
+
+static void vu_scmi_register_types(void)
+{
+    type_register_static(&vu_scmi_info);
+}
+
+type_init(vu_scmi_register_types)
diff --git a/include/hw/virtio/vhost-user-scmi.h b/include/hw/virtio/vhost-user-scmi.h
new file mode 100644
index 000000000000..50c6f1490d3a
--- /dev/null
+++ b/include/hw/virtio/vhost-user-scmi.h
@@ -0,0 +1,37 @@
+/*
+ * Vhost-user scmi virtio device
+ *
+ * Copyright (c) 2021 Viresh Kumar <viresh.kumar@linaro.org>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#ifndef _QEMU_VHOST_USER_SCMI_H
+#define _QEMU_VHOST_USER_SCMI_H
+
+#include "hw/virtio/virtio.h"
+#include "hw/virtio/vhost.h"
+#include "hw/virtio/vhost-user.h"
+#include "chardev/char-fe.h"
+
+#define TYPE_VHOST_USER_SCMI "vhost-user-scmi-device"
+OBJECT_DECLARE_SIMPLE_TYPE(VHostUserSCMI, VHOST_USER_SCMI)
+
+typedef struct {
+    CharBackend chardev;
+} VHostUserSCMIConf;
+
+struct VHostUserSCMI {
+    /*< private >*/
+    VirtIODevice parent;
+    VHostUserSCMIConf conf;
+    struct vhost_virtqueue *vhost_vq;
+    struct vhost_dev vhost_dev;
+    VhostUserState vhost_user;
+    VirtQueue *req_vq;
+    bool connected;
+
+    /*< public >*/
+};
+
+#endif /* _QEMU_VHOST_USER_SCMI_H */
diff --git a/include/standard-headers/linux/virtio_ids.h b/include/standard-headers/linux/virtio_ids.h
index b89391dff6c9..82be1d631c18 100644
--- a/include/standard-headers/linux/virtio_ids.h
+++ b/include/standard-headers/linux/virtio_ids.h
@@ -54,6 +54,7 @@
 #define VIRTIO_ID_FS			26 /* virtio filesystem */
 #define VIRTIO_ID_PMEM			27 /* virtio pmem */
 #define VIRTIO_ID_MAC80211_HWSIM	29 /* virtio mac80211-hwsim */
+#define VIRTIO_ID_SCMI			32 /* virtio cmii2c */
 #define VIRTIO_ID_I2C_ADAPTER		34 /* virtio i2c adapter */
 
 #endif /* _LINUX_VIRTIO_IDS_H */
diff --git a/tools/meson.build b/tools/meson.build
index 8271e110978b..0b1f4a6d6ea5 100644
--- a/tools/meson.build
+++ b/tools/meson.build
@@ -32,3 +32,11 @@ have_virtioi2c= (have_system and
 if have_virtioi2c
   subdir('vhost-user-i2c')
 endif
+
+have_virtioscmi= (have_system and
+    have_tools and
+    'CONFIG_LINUX' in config_host)
+
+if have_virtioscmi
+  subdir('vhost-user-scmi')
+endif
diff --git a/tools/vhost-user-scmi/50-qemu-scmi.json.in b/tools/vhost-user-scmi/50-qemu-scmi.json.in
new file mode 100644
index 000000000000..fb5a6b0a22c9
--- /dev/null
+++ b/tools/vhost-user-scmi/50-qemu-scmi.json.in
@@ -0,0 +1,5 @@
+{
+  "description": "QEMU vhost-user-scmi",
+  "type": "bridge",
+  "binary": "@libexecdir@/vhost-user-scmi"
+}
diff --git a/tools/vhost-user-scmi/main.c b/tools/vhost-user-scmi/main.c
new file mode 100644
index 000000000000..302b2d762343
--- /dev/null
+++ b/tools/vhost-user-scmi/main.c
@@ -0,0 +1,356 @@
+/*
+ * VIRTIO scmi Emulation via vhost-user
+ *
+ * Copyright (c) 2021 Viresh Kumar <viresh.kumar@linaro.org>
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#define G_LOG_DOMAIN "vhost-user-scmi"
+#define G_LOG_USE_STRUCTURED 1
+
+#include <glib.h>
+#include <gio/gunixsocketaddress.h>
+#include <glib-unix.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <inttypes.h>
+
+#include "subprojects/libvhost-user/libvhost-user-glib.h"
+#include "subprojects/libvhost-user/libvhost-user.h"
+
+/* Definitions from virtio-scmi specifications */
+#define VHOST_USER_SCMI_MAX_QUEUES       2
+ 
+/* Status */
+#define VIRTIO_SCMI_MSG_OK               0
+#define VIRTIO_SCMI_MSG_ERR              1
+
+//#define USE_SCMI_SERVER
+
+/**
+ * struct virtio_scmi_request - the virtio scmi message request header
+ * @hdr: the controlled device's address
+ * @data: used to pad to full dword
+ */
+struct virtio_scmi_request {
+	__virtio32 hdr;
+	__u8 data[];
+};
+
+struct virtio_scmi_response {
+	__virtio32 hdr;
+	__virtio32 status;
+	__u8 data[];
+};
+
+struct virtio_scmi_notification {
+	__virtio32 hdr;
+	__u8 data[];
+};
+
+/* vhost-user-scmi definitions */
+
+#ifndef container_of
+#define container_of(ptr, type, member) ({                      \
+        const typeof(((type *) 0)->member) *__mptr = (ptr);     \
+        (type *) ((char *) __mptr - offsetof(type, member));})
+#endif
+
+typedef struct {
+    VugDev dev;
+    GMainLoop *loop;
+} VuScmi;
+
+static gboolean print_cap, verbose;
+static gchar *socket_path;
+static gint socket_fd = -1;
+
+static GOptionEntry options[] = {
+    { "socket-path", 's', 0, G_OPTION_ARG_FILENAME, &socket_path,
+      "Location of vhost-user Unix domain socket, incompatible with --fd",
+      "PATH" },
+    { "fd", 'f', 0, G_OPTION_ARG_INT, &socket_fd,
+      "Specify file-descriptor of the backend, don't use with --socket-path",
+      "FD" },
+    { "print-capabilities", 'c', 0, G_OPTION_ARG_NONE, &print_cap,
+      "Output to stdout the backend capabilities in JSON format and exit",
+      NULL},
+    { "verbose", 'v', 0, G_OPTION_ARG_NONE, &verbose,
+      "Be more verbose in output", NULL},
+    { NULL }
+};
+
+/* scmi helpers */
+static void fmt_bytes(GString *s, uint8_t *bytes, int len)
+{
+    int32_t i;
+    for (i = 0; i < len; i++) {
+        if (i && i % 16 == 0) {
+            g_string_append_c(s, '\n');
+        }
+        g_string_append_printf(s, "%x ", bytes[i]);
+    }
+}
+
+static void vscmi_dump_msg(struct virtio_scmi_request *msg, size_t len)
+{
+    g_autoptr(GString) s = g_string_new("\nScmi request: ");
+
+    g_string_append_printf(s, "hdr: %x\n", msg->hdr);
+
+    fmt_bytes(s, (uint8_t *)msg->data, len-sizeof(msg->hdr));
+    g_string_append_printf(s, "\n");
+
+    g_info("%s: %s", __func__, s->str);
+}
+
+static uint8_t vscmi_xfer(VuDev *dev, struct virtio_scmi_request *msg, size_t len)
+{
+//    VuScmi *scmi = container_of(dev, VuScmi, dev.parent);
+
+    if (verbose) {
+        vscmi_dump_msg(msg, len);
+    }
+
+    return VIRTIO_SCMI_MSG_OK;
+}
+
+
+/* Virtio helpers */
+static uint64_t vscmi_get_features(VuDev *dev)
+{
+    g_info("%s\n", __func__);
+    if (verbose) {
+        g_info("%s: replying", __func__);
+    }
+    return 0;
+}
+
+static void vscmi_set_features(VuDev *dev, uint64_t features)
+{
+    g_info("%s\n", __func__);
+    if (verbose && features) {
+        g_autoptr(GString) s = g_string_new("Requested un-handled feature");
+        g_string_append_printf(s, " 0x%" PRIx64 "", features);
+        g_info("%s: %s", __func__, s->str);
+    }
+}
+
+static void vscmi_handle_ctrl(VuDev *dev, int qidx)
+{
+    VuVirtq *vq = vu_get_queue(dev, qidx);
+    struct virtio_scmi_request *out_hdr;
+    struct virtio_scmi_response *in_hdr;
+    size_t out_hdr_len, in_hdr_len;
+
+    g_info("%s idx %d\n", __func__, qidx);
+
+    for (;;) {
+        VuVirtqElement *elem;
+
+//	usleep(1000000);
+
+        elem = vu_queue_pop(dev, vq, sizeof(VuVirtqElement));
+//	g_info("vscmi_handle_ctrl element %p\n", elem);
+        if (!elem) {
+            break;
+        }
+
+        g_info("%s: got queue (in %d, out %d)", __func__, elem->in_num,
+                elem->out_num);
+
+        out_hdr = elem->out_sg[0].iov_base;
+	out_hdr_len =  elem->out_sg[0].iov_len;
+        in_hdr = elem->in_sg[0].iov_base;
+	in_hdr_len =  elem->out_sg[0].iov_len;
+
+#ifdef USE_SCMI_SERVER
+	{
+	    fwk_id_t device_id;
+
+		device_id = FWK_ID_SUB_ELEMENT(FWK_MODULE_IDX_OPTEE_MHU,0, 0);
+
+		optee_process_message(device_id.value, out_hdr);
+	}
+#else
+	vscmi_xfer(dev, out_hdr, out_hdr_len);
+	in_hdr->status = 0;
+	*((__virtio32 *)in_hdr->data) = 0x20000;
+#endif
+
+	vu_queue_push(dev, vq, elem, in_hdr_len + sizeof(*in_hdr));
+    }
+
+    vu_queue_notify(dev, vq);
+
+}
+
+static void
+vscmi_queue_set_started(VuDev *dev, int qidx, bool started)
+{
+    VuVirtq *vq = vu_get_queue(dev, qidx);
+
+    g_info("queue started %d:%d\n", qidx, started);
+
+    if (!qidx) {
+        vu_set_queue_handler(dev, vq, started ? vscmi_handle_ctrl : NULL);
+    }
+}
+
+/*
+ * vi2c_process_msg: process messages of vhost-user interface
+ *
+ * Any that are not handled here are processed by the libvhost library
+ * itself.
+ */
+static int vscmi_process_msg(VuDev *dev, VhostUserMsg *msg, int *do_reply)
+{
+    VuScmi *scmi = container_of(dev, VuScmi, dev.parent);
+
+    g_info("%s\n", __func__);
+
+    if (msg->request == VHOST_USER_NONE) {
+        g_main_loop_quit(scmi->loop);
+        return 1;
+    }
+
+    return 0;
+}
+
+static const VuDevIface vuiface = {
+    .set_features = vscmi_set_features,
+    .get_features = vscmi_get_features,
+    .queue_set_started = vscmi_queue_set_started,
+    .process_msg = vscmi_process_msg,
+};
+
+static gboolean hangup(gpointer user_data)
+{
+    GMainLoop *loop = (GMainLoop *) user_data;
+    g_info("%s: caught hangup/quit signal, quitting main loop", __func__);
+    g_main_loop_quit(loop);
+    return true;
+}
+
+static void vscmi_panic(VuDev *dev, const char *msg)
+{
+    g_info("%s\n", __func__);
+    g_critical("%s\n", msg);
+    exit(EXIT_FAILURE);
+}
+
+/* Print vhost-user.json backend program capabilities */
+static void print_capabilities(void)
+{
+    g_info("%s\n", __func__);
+    printf("{\n");
+    printf("  \"type\": \"scmi\"\n");
+    printf("}\n");
+}
+
+static void vscmi_destroy(VuScmi *scmi)
+{
+    g_info("%s\n", __func__);
+    vug_deinit(&scmi->dev);
+    if (socket_path) {
+        unlink(socket_path);
+    }
+}
+
+int main(int argc, char *argv[])
+{
+    GError *error = NULL;
+    GOptionContext *context;
+    g_autoptr(GSocket) socket = NULL;
+    VuScmi scmi = {0};
+
+    context = g_option_context_new("vhost-user emulation of SCMI device");
+    g_option_context_add_main_entries(context, options, "vhost-user-scmi");
+    if (!g_option_context_parse(context, &argc, &argv, &error)) {
+        g_printerr("option parsing failed: %s\n", error->message);
+        exit(1);
+    }
+
+    if (print_cap) {
+        print_capabilities();
+        exit(0);
+    }
+
+    if (!socket_path && socket_fd < 0) {
+        g_printerr("Please specify either --fd or --socket-path\n");
+        exit(EXIT_FAILURE);
+    }
+
+    if (verbose) {
+        g_log_set_handler(NULL, G_LOG_LEVEL_MASK, g_log_default_handler, NULL);
+        g_setenv("G_MESSAGES_DEBUG", "all", true);
+    } else {
+        g_log_set_handler(NULL, G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL |
+                          G_LOG_LEVEL_ERROR, g_log_default_handler, NULL);
+    }
+
+#ifdef USE_SCMI_SERVER
+    /* Initialize scmi server */
+    optee_arch_init();
+#endif
+
+    /*
+     * Now create a vhost-user socket that we will receive messages
+     * on. Once we have our handler set up we can enter the glib main
+     * loop.
+     */
+    if (socket_path) {
+        g_autoptr(GSocketAddress) addr = g_unix_socket_address_new(socket_path);
+        g_autoptr(GSocket) bind_socket = g_socket_new(G_SOCKET_FAMILY_UNIX,
+                    G_SOCKET_TYPE_STREAM, G_SOCKET_PROTOCOL_DEFAULT, &error);
+
+        if (!g_socket_bind(bind_socket, addr, false, &error)) {
+            g_printerr("Failed to bind to socket at %s (%s).\n",
+                       socket_path, error->message);
+            exit(EXIT_FAILURE);
+        }
+        if (!g_socket_listen(bind_socket, &error)) {
+            g_printerr("Failed to listen on socket %s (%s).\n",
+                       socket_path, error->message);
+        }
+        g_message("awaiting connection to %s", socket_path);
+        socket = g_socket_accept(bind_socket, NULL, &error);
+        if (!socket) {
+            g_printerr("Failed to accept on socket %s (%s).\n",
+                       socket_path, error->message);
+        }
+    } else {
+        socket = g_socket_new_from_fd(socket_fd, &error);
+        if (!socket) {
+            g_printerr("Failed to connect to FD %d (%s).\n",
+                       socket_fd, error->message);
+            exit(EXIT_FAILURE);
+        }
+    }
+
+    /*
+     * Create the main loop first so all the various sources can be
+     * added. As well as catching signals we need to ensure vug_init
+     * can add it's GSource watches.
+     */
+
+    scmi.loop = g_main_loop_new(NULL, FALSE);
+    /* catch exit signals */
+    g_unix_signal_add(SIGHUP, hangup, scmi.loop);
+    g_unix_signal_add(SIGINT, hangup, scmi.loop);
+
+    if (!vug_init(&scmi.dev, VHOST_USER_SCMI_MAX_QUEUES, g_socket_get_fd(socket),
+                  vscmi_panic, &vuiface)) {
+        g_printerr("Failed to initialize libvhost-user-glib.\n");
+        exit(EXIT_FAILURE);
+    }
+
+
+    g_message("entering main loop, awaiting messages");
+    g_main_loop_run(scmi.loop);
+    g_message("finished main loop, cleaning up");
+
+    g_main_loop_unref(scmi.loop);
+    vscmi_destroy(&scmi);
+}
diff --git a/tools/vhost-user-scmi/meson.build b/tools/vhost-user-scmi/meson.build
new file mode 100644
index 000000000000..7bb466c71d52
--- /dev/null
+++ b/tools/vhost-user-scmi/meson.build
@@ -0,0 +1,10 @@
+executable('vhost-user-scmi', files(
+  'main.c'),
+  dependencies: [qemuutil, glib, gio],
+  install: true,
+  install_dir: get_option('libexecdir'))
+
+configure_file(input: '50-qemu-scmi.json.in',
+               output: '50-qemu-scmi.json',
+               configuration: config_host,
+               install_dir: qemu_datadir / 'vhost-user')
-- 
2.17.1

