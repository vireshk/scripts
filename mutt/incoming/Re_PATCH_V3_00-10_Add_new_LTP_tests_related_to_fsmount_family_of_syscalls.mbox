From vireshk  Wed Feb 26 04:51:48 2020
Delivered-To: viresh.kumar@linaro.org
Received: from pop.gmail.com [74.125.24.108] 	by vireshk-i7 with POP3 (fetchmail-6.3.26) 	for <vireshk@localhost> (single-drop); Wed, 26 Feb 2020 04:51:48 +0530 (IST)
Received: by 2002:a6b:c883:0:0:0:0:0 with SMTP id y125csp1773813iof;         Tue, 25 Feb 2020 06:34:27 -0800 (PST)
X-Google-Smtp-Source: APXvYqzyKO905BuXILNnlfS/jVVB8fzSR9unNlfHMmfehdDAcgxVsGqXY4gNNhHLzHkxqo546TiZ
X-Received: by 2002:a5d:5007:: with SMTP id e7mr73998391wrt.228.1582641267216;         Tue, 25 Feb 2020 06:34:27 -0800 (PST)
ARC-Seal: i=1; a=rsa-sha256; t=1582641267; cv=none;         d=google.com; s=arc-20160816;         b=C3jsBVS9KNrblRNdf+OIUgnMhpGb/01a1ajMAzBrEGACc1N24tycelmoOkrqF0oaVd          FsDQ6gfYyfBphYe79sDT/4mMbwDJ6z8HVLlcUd0NLk0metXw11EY4Ubg05SYL6VVl2zn          /OIWTDEJe35lhCMDNHC2LKearlI2w4b+3AiuvYYVMIeO2s0H125DKuJLoAa/LzHgk+Fl          dQmRkV4o+uVLu32/+A71gn48GMmdKLaGbpQ4K8qKPAaXw1zOwyIGRRAl4CDmwgaW5hJp          h/EITqrreK52WgghCm8ddk+Y9dbFA7as/HRJgo48RRL61eCC8pUztaHsmutYWIRjLSoW          Xlog==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=arc-20160816;         h=user-agent:in-reply-to:content-disposition:mime-version:references          :reply-to:message-id:subject:cc:to:from:date;         bh=Od2H6eL8ll5zSUOrJrl207x9L28bzo4GyNM8fgfcbz0=;         b=WY+4kTHQi8GQQzdYlM0cJLNE6BSUdYrnrUuhiV8VRxeZrYRFAnplJoxZEACQedHg5A          n8iDJtxggNI0Kr5TzLoB2CVxpN2C2UNr3TJ3GDFmgNO7KJK2Xq+y7iPpAx5bpwX6vDox          dxHu/MmK7Lo2QleQtWQ3Qwa7HSCD/lfFK6u+klnBpYZPV6P+6ox/vVasQwMveBMkz11E          IY8kCyzu3v9LBDp8volxlm9EABqNU16/0zRUPpRmNRrXD7iHTi+GOlJW0q825OqkTFkg          JfKlp30pM5OmZgutUKlGNerpma82B3MSCZv/aVoTBmgibDjjQqtgqUjPTMM+3E4/gkT/          FT8w==
ARC-Authentication-Results: i=1; mx.google.com;        spf=pass (google.com: domain of pvorel@suse.cz designates 195.135.220.15 as permitted sender) smtp.mailfrom=pvorel@suse.cz
Return-Path: <pvorel@suse.cz>
Received: from mx2.suse.de (mx2.suse.de. [195.135.220.15])         by mx.google.com with ESMTPS id p17si2831389wma.126.2020.02.25.06.34.26         (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);         Tue, 25 Feb 2020 06:34:27 -0800 (PST)
Received-SPF: pass (google.com: domain of pvorel@suse.cz designates 195.135.220.15 as permitted sender) client-ip=195.135.220.15;
Authentication-Results: mx.google.com;        spf=pass (google.com: domain of pvorel@suse.cz designates 195.135.220.15 as permitted sender) smtp.mailfrom=pvorel@suse.cz
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.220.254]) 	by mx2.suse.de (Postfix) with ESMTP id 972A7B1C6; 	Tue, 25 Feb 2020 14:34:25 +0000 (UTC)
Date: Tue, 25 Feb 2020 15:23:14 +0100
From: Petr Vorel <pvorel@suse.cz>
To: Viresh Kumar <viresh.kumar@linaro.org>
Cc: ltp@lists.linux.it, Vincent Guittot <vincent.guittot@linaro.org>, 	anmar.oueja@linaro.org, Cyril Hrubis <chrubis@suse.cz>, 	Vikas.Kumar2@arm.com, Li Wang <liwang@redhat.com>, 	Zorro Lang <zlang@redhat.com>
Subject: Re: [PATCH V3 00/10] Add new LTP tests related to fsmount family of  syscalls
Message-ID: <20200225142314.GD62318@gacrux.arch.suse.de>
Reply-To: Petr Vorel <pvorel@suse.cz>
References: <cover.1582612624.git.viresh.kumar@linaro.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <cover.1582612624.git.viresh.kumar@linaro.org>
User-Agent: Mutt/1.10.1 (2018-07-13)
Status: RO
Content-Length: 12386
Lines: 464

Hi,

I addressed some of my concerns here (+ add fspick.h to remove a bit of the duplicity):
https://github.com/pevik/ltp/tree/Viresh_Kumar/fsmount.v3.fixes

LGTM, but I'd like to have more look.
I'd also appreciate somebody else to have look.

Kind regards,
Petr

diff --git lib/tst_device.c lib/tst_device.c
index c53ae36cf..d99fb8bc5 100644
--- lib/tst_device.c
+++ lib/tst_device.c
@@ -404,7 +404,7 @@ int tst_is_mounted(const char *path)
 	SAFE_FCLOSE(NULL, file);
 
 	if (!ret)
-		tst_resm(TWARN, "No device is mounted at %s", path);
+		tst_resm(TINFO, "No device is mounted at %s", path);
 
 	return ret;
 }
diff --git testcases/kernel/syscalls/fsconfig/fsconfig02.c testcases/kernel/syscalls/fsconfig/fsconfig02.c
index d51a869ac..c3722691a 100644
--- testcases/kernel/syscalls/fsconfig/fsconfig02.c
+++ testcases/kernel/syscalls/fsconfig/fsconfig02.c
@@ -7,8 +7,8 @@
 #include "tst_test.h"
 #include "lapi/fsmount.h"
 
-int fd = -1, temp_fd = -1, invalid_fd = -1;
-int aux_0 = 0, aux_1 = 1, aux_fdcwd = AT_FDCWD, aux_minus1 = -1;
+static int fd = -1, temp_fd = -1, invalid_fd = -1;
+static int aux_0 = 0, aux_1 = 1, aux_fdcwd = AT_FDCWD, aux_minus1 = -1;
 
 static struct tcase {
 	char *name;
@@ -51,9 +51,7 @@ static void setup(void)
 {
 	fsopen_supported_by_kernel();
 
-	TEST(fsopen(tst_device->fs_type, 0));
-	fd = TST_RET;
-
+	TEST(fd = fsopen(tst_device->fs_type, 0));
 	if (fd == -1)
 		tst_brk(TBROK | TERRNO, "fsopen() failed");
 
diff --git testcases/kernel/syscalls/fsmount/fsmount01.c testcases/kernel/syscalls/fsmount/fsmount01.c
index b7810df2f..6774a43ff 100644
--- testcases/kernel/syscalls/fsmount/fsmount01.c
+++ testcases/kernel/syscalls/fsmount/fsmount01.c
@@ -41,13 +41,12 @@ static void run(unsigned int n)
 	struct tcase *tc = &tcases[n];
 	int sfd, mfd;
 
-	TEST(fsopen(tst_device->fs_type, FSOPEN_CLOEXEC));
-	if (TST_RET == -1) {
+	TEST(sfd = fsopen(tst_device->fs_type, FSOPEN_CLOEXEC));
+	if (sfd == -1) {
 		tst_res(TBROK | TTERRNO, "fsopen() on %s failed",
 			tst_device->fs_type);
 		return;
 	}
-	sfd = TST_RET;
 
 	TEST(fsconfig(sfd, FSCONFIG_SET_STRING, "source", tst_device->dev, 0));
 	if (TST_RET < 0) {
diff --git testcases/kernel/syscalls/fsmount/fsmount02.c testcases/kernel/syscalls/fsmount/fsmount02.c
index c61caa8e8..90dbff1fd 100644
--- testcases/kernel/syscalls/fsmount/fsmount02.c
+++ testcases/kernel/syscalls/fsmount/fsmount02.c
@@ -33,9 +33,7 @@ static void setup(void)
 {
 	fsopen_supported_by_kernel();
 
-	TEST(fsopen(tst_device->fs_type, 0));
-	fd = TST_RET;
-
+	TEST(fd = fsopen(tst_device->fs_type, 0));
 	if (fd == -1)
 		tst_brk(TBROK | TERRNO, "fsopen() failed");
 
diff --git testcases/kernel/syscalls/fsopen/fsopen01.c testcases/kernel/syscalls/fsopen/fsopen01.c
index 51fab25d9..84cb38fcf 100644
--- testcases/kernel/syscalls/fsopen/fsopen01.c
+++ testcases/kernel/syscalls/fsopen/fsopen01.c
@@ -25,9 +25,7 @@ static void run(unsigned int n)
 	struct tcase *tc = &tcases[n];
 	int fd, fsmfd;
 
-	TEST(fsopen(tst_device->fs_type, tc->flags));
-	fd = TST_RET;
-
+	TEST(fd = fsopen(tst_device->fs_type, tc->flags));
 	if (fd == -1) {
 		tst_res(TFAIL | TERRNO, "fsopen() failed");
 		return;
diff --git testcases/kernel/syscalls/fspick/fspick.h testcases/kernel/syscalls/fspick/fspick.h
new file mode 100644
index 000000000..8d42eff05
--- /dev/null
+++ testcases/kernel/syscalls/fspick/fspick.h
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2020 Viresh Kumar <viresh.kumar@linaro.org>
+ */
+
+#ifndef FSPICK_H__
+#define FSPICK_H__
+
+#define MNTPOINT	"mntpoint"
+
+static int ismounted;
+
+static void cleanup(void)
+{
+	if (ismounted)
+		SAFE_UMOUNT(MNTPOINT);
+}
+
+static void setup(void)
+{
+	int fd, fsmfd;
+
+	fsopen_supported_by_kernel();
+
+	TEST(fd = fsopen(tst_device->fs_type, 0));
+	if (fd == -1)
+		tst_brk(TBROK | TERRNO, "fsopen() failed");
+
+	TEST(fsconfig(fd, FSCONFIG_SET_STRING, "source", tst_device->dev, 0));
+	if (TST_RET == -1) {
+		SAFE_CLOSE(fd);
+		tst_brk(TBROK | TERRNO, "fsconfig() failed");
+	}
+
+	TEST(fsconfig(fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0));
+	if (TST_RET == -1) {
+		SAFE_CLOSE(fd);
+		tst_brk(TBROK | TERRNO, "fsconfig() failed");
+	}
+
+	TEST(fsmfd = fsmount(fd, 0, 0));
+	SAFE_CLOSE(fd);
+
+	if (TST_RET == -1)
+		tst_brk(TBROK | TERRNO, "fsmount() failed");
+
+	TEST(move_mount(fsmfd, "", AT_FDCWD, MNTPOINT,
+			MOVE_MOUNT_F_EMPTY_PATH));
+	SAFE_CLOSE(fsmfd);
+
+	if (TST_RET == -1)
+		tst_brk(TBROK | TERRNO, "move_mount() failed");
+
+	ismounted = 1;
+
+	if (!tst_is_mounted(MNTPOINT))
+		tst_brk(TBROK | TERRNO, "device not mounted");
+}
+
+#endif /* FSPICK_H__ */
diff --git testcases/kernel/syscalls/fspick/fspick01.c testcases/kernel/syscalls/fspick/fspick01.c
index 9d4b28a6a..217cb1f12 100644
--- testcases/kernel/syscalls/fspick/fspick01.c
+++ testcases/kernel/syscalls/fspick/fspick01.c
@@ -6,8 +6,7 @@
  */
 #include "tst_test.h"
 #include "lapi/fsmount.h"
-
-#define MNTPOINT	"mntpoint"
+#include "fspick.h"
 
 #define TCASE_ENTRY(_flags)	{.name = "Flag " #_flags, .flags = _flags}
 
@@ -21,58 +20,6 @@ static struct tcase {
 	TCASE_ENTRY(FSPICK_EMPTY_PATH),
 };
 
-static int ismounted;
-
-static void cleanup(void)
-{
-	if (ismounted)
-		SAFE_UMOUNT(MNTPOINT);
-}
-
-static void setup(void)
-{
-	int fd, fsmfd;
-
-	fsopen_supported_by_kernel();
-
-	TEST(fsopen(tst_device->fs_type, 0));
-	fd = TST_RET;
-
-	if (fd == -1)
-		tst_brk(TBROK | TERRNO, "fsopen() failed");
-
-	TEST(fsconfig(fd, FSCONFIG_SET_STRING, "source", tst_device->dev, 0));
-	if (TST_RET == -1) {
-		SAFE_CLOSE(fd);
-		tst_brk(TBROK | TERRNO, "fsconfig failed");
-	}
-
-	TEST(fsconfig(fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0));
-	if (TST_RET == -1) {
-		SAFE_CLOSE(fd);
-		tst_brk(TBROK | TERRNO, "fsconfig failed");
-	}
-
-	TEST(fsmount(fd, 0, 0));
-	SAFE_CLOSE(fd);
-
-	if (TST_RET == -1)
-		tst_brk(TBROK | TERRNO, "fsmount() failed");
-
-	fsmfd = TST_RET;
-	TEST(move_mount(fsmfd, "", AT_FDCWD, MNTPOINT,
-			MOVE_MOUNT_F_EMPTY_PATH));
-	SAFE_CLOSE(fsmfd);
-
-	if (TST_RET == -1)
-		tst_brk(TBROK | TERRNO, "move_mount() failed");
-
-	ismounted = 1;
-
-	if (!tst_is_mounted(MNTPOINT))
-		tst_brk(TBROK | TERRNO, "device not mounted");
-}
-
 static void run(unsigned int n)
 {
 	struct tcase *tc = &tcases[n];
diff --git testcases/kernel/syscalls/fspick/fspick02.c testcases/kernel/syscalls/fspick/fspick02.c
index c702140ec..dc552c754 100644
--- testcases/kernel/syscalls/fspick/fspick02.c
+++ testcases/kernel/syscalls/fspick/fspick02.c
@@ -6,8 +6,7 @@
  */
 #include "tst_test.h"
 #include "lapi/fsmount.h"
-
-#define MNTPOINT	"mntpoint"
+#include "fspick.h"
 
 static struct tcase {
 	char *name;
@@ -21,59 +20,6 @@ static struct tcase {
 	{"invalid-flags", AT_FDCWD, MNTPOINT, 0x10, EINVAL},
 };
 
-static int ismounted;
-
-static void cleanup(void)
-{
-	if (ismounted)
-		SAFE_UMOUNT(MNTPOINT);
-}
-
-static void setup(void)
-{
-	int fd, fsmfd;
-
-	fsopen_supported_by_kernel();
-
-	TEST(fsopen(tst_device->fs_type, 0));
-	fd = TST_RET;
-
-	if (fd == -1)
-		tst_brk(TBROK | TERRNO, "fsopen() failed");
-
-	TEST(fsconfig(fd, FSCONFIG_SET_STRING, "source", tst_device->dev, 0));
-	if (TST_RET == -1) {
-		SAFE_CLOSE(fd);
-		tst_brk(TBROK | TERRNO, "fsconfig failed");
-	}
-
-	TEST(fsconfig(fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0));
-	if (TST_RET == -1) {
-		SAFE_CLOSE(fd);
-		tst_brk(TBROK | TERRNO, "fsconfig failed");
-	}
-
-	TEST(fsmount(fd, 0, 0));
-	SAFE_CLOSE(fd);
-
-	if (TST_RET == -1)
-		tst_brk(TBROK | TERRNO, "fsmount() failed");
-
-	fsmfd = TST_RET;
-
-	TEST(move_mount(fsmfd, "", AT_FDCWD, MNTPOINT,
-			MOVE_MOUNT_F_EMPTY_PATH));
-	SAFE_CLOSE(fsmfd);
-
-	if (TST_RET == -1)
-		tst_brk(TBROK | TERRNO, "move_mount() failed");
-
-	ismounted = 1;
-
-	if (!tst_is_mounted(MNTPOINT))
-		tst_brk(TBROK | TERRNO, "device not mounted");
-}
-
 static void run(unsigned int n)
 {
 	struct tcase *tc = &tcases[n];
diff --git testcases/kernel/syscalls/move_mount/move_mount01.c testcases/kernel/syscalls/move_mount/move_mount01.c
index aef0e15e1..b5513dd18 100644
--- testcases/kernel/syscalls/move_mount/move_mount01.c
+++ testcases/kernel/syscalls/move_mount/move_mount01.c
@@ -28,25 +28,23 @@ static void run(unsigned int n)
 	struct tcase *tc = &tcases[n];
 	int fsmfd, fd;
 
-	TEST(fsopen(tst_device->fs_type, 0));
-	fd = TST_RET;
-
+	TEST(fd = fsopen(tst_device->fs_type, 0));
 	if (fd == -1) {
-		tst_res(TBROK | TERRNO, "fsopen() failed");
+		tst_res(TFAIL | TERRNO, "fsopen() failed");
 		return;
 	}
 
 	TEST(fsconfig(fd, FSCONFIG_SET_STRING, "source", tst_device->dev, 0));
 	if (TST_RET == -1) {
 		SAFE_CLOSE(fd);
-		tst_res(TBROK | TERRNO, "fsconfig() failed");
+		tst_res(TFAIL | TERRNO, "fsconfig() failed");
 		return;
 	}
 
 	TEST(fsconfig(fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0));
 	if (TST_RET == -1) {
 		SAFE_CLOSE(fd);
-		tst_res(TBROK | TERRNO, "fsconfig() failed");
+		tst_res(TFAIL | TERRNO, "fsconfig() failed");
 		return;
 	}
 
@@ -54,7 +52,7 @@ static void run(unsigned int n)
 	SAFE_CLOSE(fd);
 
 	if (TST_RET == -1) {
-		tst_res(TBROK | TERRNO, "fsmount() failed");
+		tst_res(TFAIL | TERRNO, "fsmount() failed");
 		return;
 	}
 
diff --git testcases/kernel/syscalls/move_mount/move_mount02.c testcases/kernel/syscalls/move_mount/move_mount02.c
index 98b7be77f..d85381e90 100644
--- testcases/kernel/syscalls/move_mount/move_mount02.c
+++ testcases/kernel/syscalls/move_mount/move_mount02.c
@@ -32,25 +32,23 @@ static void run(unsigned int n)
 	struct tcase *tc = &tcases[n];
 	int fd;
 
-	TEST(fsopen(tst_device->fs_type, 0));
-	fd = TST_RET;
-
+	TEST(fd = fsopen(tst_device->fs_type, 0));
 	if (fd == -1) {
-		tst_res(TBROK | TERRNO, "fsopen() failed");
+		tst_res(TFAIL | TERRNO, "fsopen() failed");
 		return;
 	}
 
 	TEST(fsconfig(fd, FSCONFIG_SET_STRING, "source", tst_device->dev, 0));
 	if (TST_RET == -1) {
 		SAFE_CLOSE(fd);
-		tst_res(TBROK | TERRNO, "fsconfig() failed");
+		tst_res(TFAIL | TERRNO, "fsconfig() failed");
 		return;
 	}
 
 	TEST(fsconfig(fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0));
 	if (TST_RET == -1) {
 		SAFE_CLOSE(fd);
-		tst_res(TBROK | TERRNO, "fsconfig() failed");
+		tst_res(TFAIL | TERRNO, "fsconfig() failed");
 		return;
 	}
 
@@ -58,7 +56,7 @@ static void run(unsigned int n)
 	SAFE_CLOSE(fd);
 
 	if (TST_RET == -1) {
-		tst_res(TBROK | TERRNO, "fsmount() failed");
+		tst_res(TFAIL | TERRNO, "fsmount() failed");
 		return;
 	}
 
diff --git testcases/kernel/syscalls/open_tree/open_tree01.c testcases/kernel/syscalls/open_tree/open_tree01.c
index ef603cc27..191d3196d 100644
--- testcases/kernel/syscalls/open_tree/open_tree01.c
+++ testcases/kernel/syscalls/open_tree/open_tree01.c
@@ -52,18 +52,18 @@ static void run(unsigned int n)
 	TEST(fsconfig(fd, FSCONFIG_SET_STRING, "source", tst_device->dev, 0));
 	if (TST_RET == -1) {
 		SAFE_CLOSE(fd);
-		tst_res(TBROK | TERRNO, "fsconfig failed");
+		tst_res(TBROK | TERRNO, "fsconfig() failed");
 		return;
 	}
 
 	TEST(fsconfig(fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0));
 	if (TST_RET == -1) {
 		SAFE_CLOSE(fd);
-		tst_res(TBROK | TERRNO, "fsconfig failed");
+		tst_res(TBROK | TERRNO, "fsconfig() failed");
 		return;
 	}
 
-	TEST(fsmount(fd, 0, 0));
+	TEST(fsmfd = fsmount(fd, 0, 0));
 	SAFE_CLOSE(fd);
 
 	if (TST_RET == -1) {
@@ -71,8 +71,6 @@ static void run(unsigned int n)
 		return;
 	}
 
-	fsmfd = TST_RET;
-
 	TEST(move_mount(fsmfd, "", AT_FDCWD, MNTPOINT,
 			MOVE_MOUNT_F_EMPTY_PATH));
 	SAFE_CLOSE(fsmfd);
diff --git testcases/kernel/syscalls/open_tree/open_tree02.c testcases/kernel/syscalls/open_tree/open_tree02.c
index 5d0ffcf4e..2823531cb 100644
--- testcases/kernel/syscalls/open_tree/open_tree02.c
+++ testcases/kernel/syscalls/open_tree/open_tree02.c
@@ -44,22 +44,21 @@ static void setup(void)
 	TEST(fsconfig(fd, FSCONFIG_SET_STRING, "source", tst_device->dev, 0));
 	if (TST_RET == -1) {
 		SAFE_CLOSE(fd);
-		tst_brk(TBROK | TERRNO, "fsconfig failed");
+		tst_brk(TBROK | TERRNO, "fsconfig() failed");
 	}
 
 	TEST(fsconfig(fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0));
 	if (TST_RET == -1) {
 		SAFE_CLOSE(fd);
-		tst_brk(TBROK | TERRNO, "fsconfig failed");
+		tst_brk(TBROK | TERRNO, "fsconfig() failed");
 	}
 
-	TEST(fsmount(fd, 0, 0));
+	TEST(fsmfd = fsmount(fd, 0, 0));
 	SAFE_CLOSE(fd);
 
 	if (TST_RET == -1)
 		tst_brk(TBROK | TERRNO, "fsmount() failed");
 
-	fsmfd = TST_RET;
 	TEST(move_mount(fsmfd, "", AT_FDCWD, MNTPOINT,
 			MOVE_MOUNT_F_EMPTY_PATH));
 	SAFE_CLOSE(fsmfd);

