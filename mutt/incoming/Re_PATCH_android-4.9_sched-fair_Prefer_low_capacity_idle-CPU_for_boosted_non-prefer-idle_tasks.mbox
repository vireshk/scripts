From vireshk  Wed Mar  7 08:11:55 2018
Delivered-To: viresh.kumar@linaro.org
Received: from gmail-pop.l.google.com [74.125.68.109] 	by vireshk-i7 with POP3 (fetchmail-6.3.26) 	for <vireshk@localhost> (single-drop); Wed, 07 Mar 2018 08:11:55 +0530 (IST)
Received: by 10.2.79.206 with SMTP id r75csp3595267jad;         Tue, 6 Mar 2018 03:27:00 -0800 (PST)
X-Google-Smtp-Source: AG47ELuZ21YDSSjR6SH4eqlJKH7WHbxhV/BLVeYw/SucE51kUc79mA4d07Lv4WvVvw1Mb4SWINEI
X-Received: by 10.202.97.87 with SMTP id v84mr11847370oib.12.1520335620887;         Tue, 06 Mar 2018 03:27:00 -0800 (PST)
ARC-Seal: i=1; a=rsa-sha256; t=1520335620; cv=none;         d=google.com; s=arc-20160816;         b=tknhWo121UXdWzs6Le0IDchjcKPUKkoa7ePL4A3FKZBXi3Rfqu3zbsL1b3ngniYTIF          w3/OvH13JhYBLag0RZdUG8HqTe3H5R0Co1MxKVxoBFTEme3sbUMBmWTy4cqkZwIyDoJ1          Y2HUXCVjNIkyNRlKBS4IzbKt/z9Z4yaDpkaHns+tA8mxQO0vxC2vPhGcxfxaiPLw87aD          KDQ5ewzSfNSnCpRiHu1xFJf2Ng9N1L+RMP32t2/JWRSn1qcZlz4Z9Q8vSHpAUUFxN1U7          DCx34+oOIAz8iDPNry1UcImhBjfpjzKqxwHy4dviVm/+hwvbZfg1AwvECJZeezucTu7n          B+zQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=arc-20160816;         h=user-agent:in-reply-to:content-disposition:mime-version:references          :message-id:subject:cc:to:from:date:arc-authentication-results;         bh=3C9dO9UsYzpIMLQ2z/CtZglUNvQL2vCGydLrlA/flUI=;         b=sl91NA3AvcEBRL85wztIcfrgjXP5Aalmll9V5Ug2qq6ckTHrQ7MIGp05hiTqVC3/gu          3TgABYeRiAK3blbZwSEZrb+F5jhW00GCzn87nh2I5ZVOJXgausDlx05PXhMpqC6giBJe          TICfYbEHzaDUVdXtj3opvgIgmaNhBncO98IfeZpcscUKM+4MX9o+oAjxwqfVNkUXkPmO          7GKfgSq2naAX26e8YKcOHNAP299PmSKtG832G4ODks3ZguX1ThdtY2keAqNEBec7NSES          QoyH5+Ne6+MjXKxldgfXGIhqs/oo4niaHPgDkeuRDZCKYrUozRTXtAuGNSYZoSnntXC4          Ahww==
ARC-Authentication-Results: i=1; mx.google.com;        spf=pass (google.com: domain of patrick.bellasi@arm.com designates 217.140.101.70 as permitted sender) smtp.mailfrom=patrick.bellasi@arm.com
Return-Path: <patrick.bellasi@arm.com>
Received: from foss.arm.com (usa-sjc-mx-foss1.foss.arm.com. [217.140.101.70])         by mx.google.com with ESMTP id d15si4265512otk.62.2018.03.06.03.27.00;         Tue, 06 Mar 2018 03:27:00 -0800 (PST)
Received-SPF: pass (google.com: domain of patrick.bellasi@arm.com designates 217.140.101.70 as permitted sender) client-ip=217.140.101.70;
Authentication-Results: mx.google.com;        spf=pass (google.com: domain of patrick.bellasi@arm.com designates 217.140.101.70 as permitted sender) smtp.mailfrom=patrick.bellasi@arm.com
Received: from usa-sjc-imap-foss1.foss.arm.com (unknown [10.72.51.249]) 	by usa-sjc-mx-foss1.foss.arm.com (Postfix) with ESMTP id 356621435; 	Tue,  6 Mar 2018 03:27:00 -0800 (PST)
Received: from e110439-lin (e110439-lin.cambridge.arm.com [10.1.210.68]) 	by usa-sjc-imap-foss1.foss.arm.com (Postfix) with ESMTPSA id 035593F24A; 	Tue,  6 Mar 2018 03:26:58 -0800 (PST)
Date: Tue, 6 Mar 2018 11:26:56 +0000
From: Patrick Bellasi <patrick.bellasi@arm.com>
To: Viresh Kumar <viresh.kumar@linaro.org>
Cc: "Cc: EAS Dev" <eas-dev@lists.linaro.org>, 	Vincent Guittot <vincent.guittot@linaro.org>, 	Daniel Lezcano <daniel.lezcano@linaro.org>, 	Dietmar Eggemann <Dietmar.Eggemann@arm.com>, 	Leo Yan <leo.yan@linaro.org>
Subject: Re: [PATCH android-4.9] sched/fair: Prefer low capacity idle-CPU for  boosted non-prefer-idle tasks
Message-ID: <20180306112656.GS5807@e110439-lin>
References: <d2533cc6ccb17269bacab9a720eff8162dcbc06e.1520245603.git.viresh.kumar@linaro.org>  <20180305125236.GO5807@e110439-lin>  <CAKohpokah__ZogykNBYk=q-iUAr720xmViz5N4+Ap7OR-VUHAg@mail.gmail.com>  <20180305155359.GP5807@e110439-lin>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="VS++wcV0S1rZb1Fb"
Content-Disposition: inline
In-Reply-To: <20180305155359.GP5807@e110439-lin>
User-Agent: Mutt/1.5.24 (2015-08-30)
Status: RO
X-Status: A
Content-Length: 4848
Lines: 140


--VS++wcV0S1rZb1Fb
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

On 05-Mar 15:53, Patrick Bellasi wrote:
> On 05-Mar 20:44, Viresh Kumar wrote:
> > On 5 March 2018 at 18:22, Patrick Bellasi <patrick.bellasi@arm.com> wrote:
> > > On 05-Mar 15:57, Viresh Kumar wrote:

[...]

> > Well, that's what we want to do but we will never do that. The very next
> > statement after looking for lowest capacity is this:
> > 
> > if ((capacity_orig - min_capped_util) < target_idle_max_spare_cap)
> >         continue;
> 
> Hops, wait... got it... you are looking at the android-4.9-eas-dev
> branch!
> 
> ... I was considering the "mainline" android-4.9 ACK
> 
> > If we start from a big CPU, then the above expression will *always*
> > evaluate to "true" for a little CPU and so we never go to the rest of
> > the code for little CPUs. And that's a bug as we probably don't want
> > that behavior.
> 
> Yes, looking at that code... it seems that we end up favouring a big
> CPU over a LITTLE... which is a behavior chance wrt the original code.
> 
> Let seem what we can do with the snippet above... since it's not yet
> merged in ACK...

Here is in attachment a patch which should fix the issue Viresh/Leo reported.
Comments / Tomatoes?

Cheers Patrick

-- 
#include <best/regards.h>

Patrick Bellasi

--VS++wcV0S1rZb1Fb
Content-Type: text/x-diff; charset=us-ascii
Content-Disposition: attachment; filename="0001-sched-fair-fix-backup-selection-for-prefer_idle.patch"

>From ac90d5a2bd4886f7087026d204734ed3691ca03f Mon Sep 17 00:00:00 2001
From: Patrick Bellasi <patrick.bellasi@arm.com>
Date: Tue, 6 Mar 2018 11:11:17 +0000
Subject: [PATCH] sched/fair: fix backup selection for !prefer_idle

Non prefer_idle tasks should be scheduled preferably on more energy
efficient CPUs when there are only IDLE CPUs in the system.
This was the behavior (at least for !sysctl_sched_cstate_aware) systems
provided by find_best_target before:

   88a968ca63f8 sched/fair: use min capacity when evaluating idle backup cpus

which instead forces the selection of a big IDLE CPU over a LITTLE IDLE
CPU, especially when CPUs are visited from big to LITTLEs.

Since we wanna find_best_target to provide the same behaviors
independently from the CPUs visiting ordering, this patch fixes the
above issue by resetting the "min capacity" search criteria (i.e. the
maximization of the spare capacity) conditions every time we find a more
energy efficient CPU (i.e. assuming lower capacity_orig means more
energy efficient CPU).

While at fixing this, we also rename "target_idle_max_spare_cap" into
"best_idle_max_spare_cap" which better matches the naming conventions
used for case B related variables.

Change-Id: Ie6b693b11202a98a675a93c25a472be572623dc0
Reported-by: Viresh Kumar <viresh.kumar@linaro.org>
Reported-by: Leo Yan <leo.yan@linaro.org>
Signed-off-by: Patrick Bellasi <patrick.bellasi@arm.com>
---
 kernel/sched/fair.c | 21 +++++++++++++++------
 1 file changed, 15 insertions(+), 6 deletions(-)

diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index 1f1a73c8b7c9..9d2780c8c80b 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -6743,7 +6743,7 @@ static inline int find_best_target(struct task_struct *p, int *backup_cpu,
 	unsigned long target_max_spare_cap = 0;
 	unsigned long target_util = ULONG_MAX;
 	unsigned long best_active_util = ULONG_MAX;
-	unsigned long target_idle_max_spare_cap = 0;
+	unsigned long best_idle_max_spare_cap = 0;
 	int best_idle_cstate = INT_MAX;
 	struct sched_domain *sd;
 	struct sched_group *sg;
@@ -6929,15 +6929,25 @@ static inline int find_best_target(struct task_struct *p, int *backup_cpu,
 			 */
 			if (idle_cpu(i)) {
 				int idle_idx = idle_get_state_idx(cpu_rq(i));
+				int max_spare_cap;
 
 				/* Select idle CPU with lower cap_orig */
 				if (capacity_orig > best_idle_min_cap_orig)
 					continue;
-				/* Favor CPUs that won't end up running at a
+
+				/*
+				 * A more energy efficient CPU has been found,
+				 * let's reset the conditions for the
+				 * following min_capped_utilization check
+				 */
+				best_idle_max_spare_cap = 0;
+
+				/*
+				 * Favor CPUs that won't end up running at a
 				 * high OPP.
 				 */
-				if ((capacity_orig - min_capped_util) <
-					target_idle_max_spare_cap)
+				max_spare_cap = capacity_orig - min_capped_util;
+				if (max_spare_cap < best_idle_max_spare_cap)
 					continue;
 
 				/*
@@ -6951,9 +6961,8 @@ static inline int find_best_target(struct task_struct *p, int *backup_cpu,
 					continue;
 
 				/* Keep track of best idle CPU */
+				best_idle_max_spare_cap = max_spare_cap;
 				best_idle_min_cap_orig = capacity_orig;
-				target_idle_max_spare_cap = capacity_orig -
-							    min_capped_util;
 				best_idle_cstate = idle_idx;
 				best_idle_cpu = i;
 				continue;
-- 
2.15.1


--VS++wcV0S1rZb1Fb--

